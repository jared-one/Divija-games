<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Divija | The Calculus of the Heart</title>
    <!-- Prevent 404 Favicon Error -->
    <link rel="icon" href="data:,">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&family=Cinzel:wght@700&display=swap');

        :root {
            --bg: #050505;
            --heart-red: #ff4d4d;
            --soul-cyan: #00f3ff;
            --gold: #ffd700;
            --grid: rgba(255,255,255,0.1);
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'VT323', monospace;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* --- CRT MONITOR EFFECT --- */
        #crt-frame {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 1024px;
            aspect-ratio: 4/3;
            background: #000;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border: 2px solid #333;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        /* Scanlines */
        .scanlines {
            position: absolute; inset: 0; pointer-events: none; z-index: 10;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
        }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute; inset: 0; pointer-events: none; z-index: 5;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 30px;
        }

        .hud-bar {
            display: flex; justify-content: space-between; align-items: flex-end;
            text-shadow: 2px 2px 0px #000;
            font-size: 24px; color: white;
        }

        .hp-bar {
            width: 200px; height: 20px; background: #333; border: 2px solid white;
            position: relative; margin-left: 10px; display: inline-block; vertical-align: middle;
        }
        .hp-fill {
            height: 100%; background: var(--gold); width: 100%;
            transition: width 0.2s;
        }
        .resilience-text { color: var(--soul-cyan); }

        /* --- DIALOGUE BOX (Undertale Style) --- */
        #dialogue-box {
            position: absolute; bottom: 5%; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 700px;
            background: #000;
            border: 4px solid white;
            padding: 20px;
            font-size: 28px;
            color: white;
            display: none;
            font-family: 'VT323', monospace;
            line-height: 1.2;
        }
        .dialogue-face {
            float: left; width: 80px; height: 80px; margin-right: 20px;
            border: 2px solid white; background: #000;
            display: flex; align-items: center; justify-content: center;
            font-size: 40px;
        }

        /* --- SCREENS --- */
        .screen {
            position: absolute; inset: 0; z-index: 20;
            background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
            transition: opacity 0.5s;
        }
        .hidden { opacity: 0; pointer-events: none; }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: 4rem; color: var(--gold); margin: 0 0 20px 0;
            text-shadow: 0 0 10px var(--gold); text-align: center;
        }
        
        .btn {
            background: transparent; color: white; border: 2px solid white;
            padding: 15px 40px; font-family: 'VT323', monospace; font-size: 24px;
            cursor: pointer; margin-top: 30px; text-transform: uppercase;
            transition: all 0.2s;
        }
        .btn:hover { background: white; color: black; box-shadow: 0 0 20px white; transform: scale(1.05); }

        .controls-hint {
            color: #888; margin-top: 20px; font-size: 18px; text-align: center;
        }
        .key { border: 1px solid #666; padding: 2px 6px; border-radius: 4px; color: #fff; }

        /* FLICKER ANIMATION */
        .flicker { animation: flicker 2s infinite; }
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
            52% { opacity: 0.2; }
            54% { opacity: 0.8; }
        }
    </style>
</head>
<body>

<div id="crt-frame">
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>

    <div id="ui-layer">
        <div class="hud-bar">
            <div>
                <span>DIVIJA</span>
                <span style="font-size: 16px; color: #888; margin-left: 10px;">LV 1</span>
                <div class="hp-bar"><div class="hp-fill" id="hp-val"></div></div>
                <span id="hp-text" style="font-size: 20px; margin-left: 10px;">20/20</span>
            </div>
            <div class="resilience-text">TP: <span id="tp-val">0</span>%</div>
        </div>

        <div id="dialogue-box">
            <div class="dialogue-face" id="face-icon">♥</div>
            <span id="dialogue-text"></span>
            <div style="font-size: 16px; color: #666; margin-top: 10px; text-align: right;">[Z] to Continue</div>
        </div>
    </div>

    <!-- TITLE SCREEN -->
    <div id="title-screen" class="screen">
        <h1 class="flicker">THE CALCULUS<br>OF THE HEART</h1>
        <div class="controls-hint">
            <span class="key">ARROWS</span> Move &nbsp; 
            <span class="key">SHIFT</span> Focus &nbsp; 
            <span class="key">Z</span> Interact &nbsp; 
            <span class="key">X</span> Bomb
        </div>
        <button class="btn" id="btn-start">INITIATE SEQUENCE</button>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="game-over" class="screen hidden">
        <h1 style="color: var(--heart-red)">HEART BROKEN</h1>
        <p style="color: white; font-size: 24px;">Determined souls do not stay shattered.</p>
        <button class="btn" id="btn-retry">RESTORE</button>
    </div>

    <!-- WIN SCREEN -->
    <div id="win-screen" class="screen hidden">
        <h1 style="color: var(--soul-cyan)">EQUATION BALANCED</h1>
        <div style="text-align: center; color: white; font-size: 22px; max-width: 600px;">
            <p>You navigated the chaos. You proved the theorem.</p>
            <p style="margin-top: 40px; color: var(--gold); font-size: 28px; line-height: 1.5;">
                As much as you may hate to hear this:<br>
                I will always be <strong>DADDY</strong>
            </p>
        </div>
    </div>
</div>

<!-- AUDIO -->
<audio id="bgm" loop preload="auto">
    <!-- Ensure this file exists in the folder -->
    <source src="fallen-down.mp3" type="audio/mpeg">
</audio>

<script>
/**
 * ENGINE: "HEART_CORE_V2"
 * 
 * Fixes:
 * - Strict null checks in update loop
 * - Asset generation on the fly (no external images needed)
 * - Robust State Machine
 */

const CONFIG = {
    width: 640,
    height: 480,
    colors: {
        bg: '#050505',
        arena: '#ffffff',
        heart: '#ff4d4d',
        bullet: '#ffffff',
        graze: '#00f3ff',
        warn: '#ff0000'
    }
};

// --- 1. INPUT HANDLING ---
const Input = {
    keys: {},
    init() {
        window.addEventListener('keydown', e => {
            // Prevent scrolling with arrows/space
            if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
                e.preventDefault();
            }
            this.keys[e.key.toLowerCase()] = true;
        });
        window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
    },
    isDown(k) {
        if (k === 'up') return this.keys['arrowup'] || this.keys['w'];
        if (k === 'down') return this.keys['arrowdown'] || this.keys['s'];
        if (k === 'left') return this.keys['arrowleft'] || this.keys['a'];
        if (k === 'right') return this.keys['arrowright'] || this.keys['d'];
        if (k === 'z') return this.keys['z'] || this.keys['enter'];
        if (k === 'x') return this.keys['x'];
        if (k === 'shift') return this.keys['shift'];
        return false;
    }
};

// --- 2. AUDIO SYNTH (SFX) ---
const Sfx = {
    ctx: null,
    init() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    play(type) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        const now = this.ctx.currentTime;
        
        if (type === 'text') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(200, now);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.05);
            osc.start(now);
            osc.stop(now + 0.05);
        } else if (type === 'hit') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.2);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
        } else if (type === 'graze') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, now);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
        } else if (type === 'bomb') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.linearRampToValueAtTime(800, now + 0.5);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.5);
            osc.start(now);
            osc.stop(now + 0.5);
        }
    }
};

// --- 3. GRAPHICS GENERATOR (Procedural Assets) ---
const Sprites = {
    heart: null,
    bullet: null,
    enemy: null,
    
    generate() {
        // Player Heart
        this.heart = this.createCanvas(32, 32, ctx => {
            ctx.fillStyle = CONFIG.colors.heart;
            ctx.beginPath();
            ctx.moveTo(16, 28);
            ctx.bezierCurveTo(16, 26, 30, 18, 30, 10);
            ctx.bezierCurveTo(30, 0, 18, 0, 16, 10);
            ctx.bezierCurveTo(14, 0, 2, 0, 2, 10);
            ctx.bezierCurveTo(2, 18, 16, 26, 16, 28);
            ctx.fill();
        });

        // Bullet
        this.bullet = this.createCanvas(16, 16, ctx => {
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(8, 8, 5, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#888'; ctx.lineWidth=1; ctx.stroke();
        });
        
        // Enemy (Entropy)
        this.enemy = this.createCanvas(64, 64, ctx => {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            // Draw a geometric mess (Entropy)
            ctx.beginPath();
            for(let i=0; i<8; i++) {
                ctx.moveTo(32,32);
                ctx.lineTo(32 + Math.cos(i)*25, 32 + Math.sin(i)*25);
            }
            ctx.stroke();
            ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.arc(32,32,10,0,Math.PI*2); ctx.fill(); ctx.stroke();
        });
    },
    
    createCanvas(w, h, fn) {
        const c = document.createElement('canvas');
        c.width = w; c.height = h;
        fn(c.getContext('2d'));
        return c;
    }
};

// --- 4. GAME ENTITIES ---
class Player {
    constructor() {
        this.x = CONFIG.width / 2;
        this.y = CONFIG.height / 2;
        this.hp = 20;
        this.maxHp = 20;
        this.tp = 0; // Resilience (0-100)
        this.speed = 4;
        this.focusSpeed = 2;
        this.iframes = 0;
        this.radius = 4; // Hitbox radius (very small, Touhou style)
    }

    update(arena) {
        // Movement
        const spd = Input.isDown('shift') ? this.focusSpeed : this.speed;
        let dx = 0, dy = 0;
        
        if (Input.isDown('left')) dx = -spd;
        if (Input.isDown('right')) dx = spd;
        if (Input.isDown('up')) dy = -spd;
        if (Input.isDown('down')) dy = spd;

        this.x += dx;
        this.y += dy;

        // Clamp to Arena
        const margin = 8;
        this.x = Math.max(arena.x + margin, Math.min(arena.x + arena.w - margin, this.x));
        this.y = Math.max(arena.y + margin, Math.min(arena.y + arena.h - margin, this.y));

        // Iframes
        if (this.iframes > 0) this.iframes--;
        
        // Bomb
        if (Input.isDown('x') && this.tp >= 100) {
            this.tp = 0;
            Game.clearBullets();
            Sfx.play('bomb');
            // Shake effect
            Game.arena.shake = 20;
        }
    }

    draw(ctx) {
        // Blink if hit
        if (this.iframes > 0 && Math.floor(Date.now() / 60) % 2 === 0) return;
        
        // Draw Heart
        ctx.drawImage(Sprites.heart, this.x - 16, this.y - 16);
        
        // Draw Hitbox (Only when focused)
        if (Input.isDown('shift')) {
            ctx.fillStyle = 'red';
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
        }
    }
}

class Bullet {
    constructor(x, y, angle, speed, type) {
        this.x = x; this.y = y;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.type = type; // 'linear', 'sine', 'accel'
        this.timer = 0;
        this.grazed = false;
        this.active = true;
    }

    update() {
        this.timer++;
        
        if (this.type === 'sine') {
            this.x += this.vx + Math.cos(this.timer * 0.1) * 2;
            this.y += this.vy;
        } else {
            this.x += this.vx;
            this.y += this.vy;
        }

        // Cleanup OOB
        if (this.x < -20 || this.x > CONFIG.width + 20 || this.y < -20 || this.y > CONFIG.height + 20) {
            this.active = false;
        }
    }

    draw(ctx) {
        ctx.drawImage(Sprites.bullet, this.x - 8, this.y - 8);
    }
}

// --- 5. GAME ENGINE CORE ---
const Game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: null,
    state: 'MENU', // MENU, PLAY, DIALOGUE, OVER, WIN
    
    player: null,
    bullets: [],
    
    // Arena (The Box)
    arena: { x: 320, y: 240, w: 10, h: 10, targetW: 250, targetH: 250, shake: 0 },
    
    // Scripting
    script: [],
    step: 0,
    timer: 0,
    
    init() {
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = CONFIG.width;
        this.canvas.height = CONFIG.height;
        this.ctx.imageSmoothingEnabled = false;
        
        Input.init();
        Sfx.init();
        Sprites.generate();
        
        // Definition of the "Calculus of the Heart" Timeline
        this.script = [
            { cmd: 'text', msg: "Initializing Simulation...", face: 'sys' },
            { cmd: 'text', msg: "Subject: Divija.", face: 'sys' },
            { cmd: 'text', msg: "Variable: Toughness.", face: 'sys' },
            { cmd: 'text', msg: "Warning: High Entropy detected.", face: 'sys' },
            { cmd: 'battle', pattern: 'rain', time: 300 },
            { cmd: 'text', msg: "Divija: \"Why is this so chaotic?\"", face: 'heart' },
            { cmd: 'text', msg: "System: \"Life is noise. You are the signal.\"", face: 'sys' },
            { cmd: 'battle', pattern: 'sine', time: 400 },
            { cmd: 'text', msg: "System: \"Your independence is a shield.\"", face: 'sys' },
            { cmd: 'text', msg: "System: \"But shields can be heavy.\"", face: 'sys' },
            { cmd: 'battle', pattern: 'circle', time: 500 },
            { cmd: 'text', msg: "Divija: \"I can calculate the trajectory.\"", face: 'heart' },
            { cmd: 'text', msg: "Divija: \"It's just math.\"", face: 'heart' },
            { cmd: 'text', msg: "System: \"Correct. Solving for Love...\"", face: 'sys' },
            { cmd: 'battle', pattern: 'spiral', time: 600 },
            { cmd: 'end' }
        ];
        
        requestAnimationFrame(() => this.loop());
    },

    reset() {
        this.player = new Player();
        this.bullets = [];
        this.step = 0;
        this.timer = 0;
        this.arena = { x: 320, y: 240, w: 10, h: 10, targetW: 250, targetH: 250, shake: 0 };
        this.nextEvent();
        
        // Play music
        const bgm = document.getElementById('bgm');
        bgm.volume = 0.4;
        bgm.play().catch(e => console.log("Click to play audio"));
    },

    nextEvent() {
        if (this.step >= this.script.length) {
            this.state = 'WIN';
            document.getElementById('ui-layer').style.opacity = '0';
            document.getElementById('win-screen').classList.remove('hidden');
            return;
        }

        const ev = this.script[this.step];
        this.step++;

        if (ev.cmd === 'text') {
            this.state = 'DIALOGUE';
            this.showDialogue(ev.msg, ev.face);
        } else if (ev.cmd === 'battle') {
            this.state = 'PLAY';
            this.battleTimer = ev.time;
            this.pattern = ev.pattern;
            this.hideDialogue();
            this.arena.targetW = 300; // Expand for battle
            this.arena.targetH = 300;
        } else if (ev.cmd === 'end') {
            this.state = 'WIN';
            document.getElementById('ui-layer').style.opacity = '0';
            document.getElementById('win-screen').classList.remove('hidden');
        }
    },

    // --- MAIN LOOP ---
    loop() {
        // Clear
        this.ctx.fillStyle = CONFIG.colors.bg;
        this.ctx.fillRect(0, 0, CONFIG.width, CONFIG.height);

        // Update Logic
        if (this.state === 'PLAY' || this.state === 'DIALOGUE') {
            this.updateArena();
            this.drawArena();
            
            // Only update player if we have one (Fix for null error)
            if (this.player) {
                this.player.update(this.getArenaRect());
                this.player.draw(this.ctx);
            }

            this.updateBullets();
            
            if (this.state === 'PLAY') {
                this.handleBattle();
            }
            
            if (this.state === 'DIALOGUE') {
                this.handleDialogue();
            }
        }

        requestAnimationFrame(() => this.loop());
    },

    // --- GAMEPLAY SYSTEMS ---
    updateArena() {
        // Smooth resize
        this.arena.w += (this.arena.targetW - this.arena.w) * 0.1;
        this.arena.h += (this.arena.targetH - this.arena.h) * 0.1;
        
        // Shake decay
        if (this.arena.shake > 0) this.arena.shake *= 0.9;
        if (this.arena.shake < 0.5) this.arena.shake = 0;
    },

    getArenaRect() {
        const x = (CONFIG.width - this.arena.w) / 2 + (Math.random()-0.5)*this.arena.shake;
        const y = (CONFIG.height - this.arena.h) / 2 + (Math.random()-0.5)*this.arena.shake;
        return { x, y, w: this.arena.w, h: this.arena.h };
    },

    drawArena() {
        const rect = this.getArenaRect();
        
        // Draw Grid inside
        this.ctx.save();
        this.ctx.beginPath();
        this.ctx.rect(rect.x, rect.y, rect.w, rect.h);
        this.ctx.clip();
        
        // Moving grid
        this.ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        this.ctx.lineWidth = 2;
        const offset = (Date.now() / 20) % 40;
        for(let i=0; i<rect.w+40; i+=40) {
            this.ctx.beginPath();
            this.ctx.moveTo(rect.x + i - offset, rect.y);
            this.ctx.lineTo(rect.x + i - offset, rect.y + rect.h);
            this.ctx.stroke();
        }
        this.ctx.restore();

        // Draw Box Border
        this.ctx.strokeStyle = 'white';
        this.ctx.lineWidth = 4;
        this.ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
        
        // Draw Entropy Enemy (Abstract)
        if (this.state === 'PLAY') {
            this.ctx.drawImage(Sprites.enemy, CONFIG.width/2 - 32, rect.y - 80);
        }
    },

    handleBattle() {
        if (!this.player) return;

        this.battleTimer--;
        if (this.battleTimer <= 0) {
            this.bullets = []; // Clear bullets between phases
            this.arena.targetW = 10; // Shrink for dialogue
            this.arena.targetH = 10;
            // Wait for shrink
            if (this.arena.w < 20) this.nextEvent();
            return;
        }

        // Spawners
        const t = this.battleTimer;
        const cx = CONFIG.width/2;
        const cy = CONFIG.height/2 - 100; // Enemy pos

        if (this.pattern === 'rain') {
            if (t % 10 === 0) {
                const x = this.getArenaRect().x + Math.random() * this.arena.w;
                this.bullets.push(new Bullet(x, 0, Math.PI/2, 3, 'linear'));
            }
        }
        else if (this.pattern === 'sine') {
            if (t % 20 === 0) {
                this.bullets.push(new Bullet(cx, cy, Math.PI/2, 2, 'sine'));
            }
        }
        else if (this.pattern === 'circle') {
            if (t % 40 === 0) {
                for(let i=0; i<10; i++) {
                    this.bullets.push(new Bullet(cx, cy, (Math.PI*2/10)*i + t*0.01, 2.5, 'linear'));
                }
            }
        }
        else if (this.pattern === 'spiral') {
            if (t % 4 === 0) {
                this.bullets.push(new Bullet(cx, cy, t * 0.2, 3, 'linear'));
                this.bullets.push(new Bullet(cx, cy, t * 0.2 + Math.PI, 3, 'linear'));
            }
        }
    },

    updateBullets() {
        if (!this.player) return;

        for (let i = this.bullets.length - 1; i >= 0; i--) {
            let b = this.bullets[i];
            b.update();
            b.draw(this.ctx);

            if (!b.active) {
                this.bullets.splice(i, 1);
                continue;
            }

            // Collision Logic
            // 1. Graze (Close shave)
            const dx = b.x - this.player.x;
            const dy = b.y - this.player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < 25 && !b.grazed) {
                b.grazed = true;
                this.player.tp = Math.min(100, this.player.tp + 10);
                Sfx.play('graze');
                // Visual flare
            }

            // 2. Hit
            if (dist < 6 && this.player.iframes === 0) {
                this.player.hp -= 5;
                this.player.iframes = 60; // 1s invincibility
                Sfx.play('hit');
                this.arena.shake = 10;
                b.active = false;

                if (this.player.hp <= 0) {
                    this.state = 'OVER';
                    document.getElementById('ui-layer').style.opacity = '0';
                    document.getElementById('game-over').classList.remove('hidden');
                }
            }
        }

        // Update UI Bars
        document.getElementById('hp-val').style.width = (this.player.hp / this.player.maxHp * 100) + '%';
        document.getElementById('hp-text').textContent = Math.max(0, this.player.hp) + "/20";
        document.getElementById('tp-val').textContent = Math.floor(this.player.tp);
    },

    clearBullets() {
        this.bullets = [];
    },

    // --- DIALOGUE HANDLING ---
    showDialogue(msg, face) {
        const box = document.getElementById('dialogue-box');
        const txt = document.getElementById('dialogue-text');
        const faceIcon = document.getElementById('face-icon');
        
        box.style.display = 'block';
        txt.textContent = '';
        this.dialogueFullText = msg;
        this.dialogueIdx = 0;
        this.dialogueTimer = setInterval(() => this.typeWriter(), 30);
        
        // Set Face
        if (face === 'heart') {
            faceIcon.innerHTML = '♥';
            faceIcon.style.color = CONFIG.colors.heart;
        } else {
            faceIcon.innerHTML = '#';
            faceIcon.style.color = CONFIG.colors.graze;
        }
    },

    typeWriter() {
        if (this.dialogueIdx < this.dialogueFullText.length) {
            const char = this.dialogueFullText.charAt(this.dialogueIdx);
            document.getElementById('dialogue-text').textContent += char;
            this.dialogueIdx++;
            if (this.dialogueIdx % 2 === 0) Sfx.play('text');
        } else {
            clearInterval(this.dialogueTimer);
        }
    },

    handleDialogue() {
        if (Input.isDown('z') && !this.keyLock && this.dialogueIdx >= this.dialogueFullText.length) {
            this.keyLock = true;
            this.nextEvent();
        }
        if (!Input.isDown('z')) this.keyLock = false;
        // Instant text skip
        if (Input.isDown('x')) {
            this.dialogueIdx = this.dialogueFullText.length;
            document.getElementById('dialogue-text').textContent = this.dialogueFullText;
        }
    },

    hideDialogue() {
        document.getElementById('dialogue-box').style.display = 'none';
        clearInterval(this.dialogueTimer);
    }
};

// --- EVENTS ---
document.getElementById('btn-start').addEventListener('click', () => {
    document.getElementById('title-screen').classList.add('hidden');
    Game.state = 'PLAY';
    Game.reset();
});

document.getElementById('btn-retry').addEventListener('click', () => {
    document.getElementById('game-over').classList.add('hidden');
    document.getElementById('ui-layer').style.opacity = '1';
    Game.state = 'PLAY';
    Game.reset();
});

// Start loop immediately to draw menu bg
Game.init();

</script>
</body>
</html>
