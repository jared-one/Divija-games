<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Divija: The Calculus of the Heart</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚ù§Ô∏è</text></svg>">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&family=Cinzel:wght@700&display=swap');

        :root {
            --bg: #050505;
            --heart: #ff4d4d;
            --soul: #00f3ff;
            --gold: #ffd700;
            --text-shadow: 2px 2px 0px #000;
        }

        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'VT323', monospace;
            color: white;
            user-select: none;
        }

        /* CRT MONITOR CONTAINER */
        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            background: #000;
            border: 1px solid #333;
            box-shadow: 0 0 100px rgba(0, 243, 255, 0.1);
            overflow: hidden;
        }

        canvas {
            display: block;
            image-rendering: pixelated; /* Crucial for retro look */
        }

        /* UI OVERLAY */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 24px;
            text-shadow: var(--text-shadow);
        }

        .bar-container {
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid white;
            margin-left: 10px;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.1s linear;
        }

        #hp-fill { background: var(--gold); }
        #tp-fill { background: var(--soul); width: 0%; }

        /* DIALOGUE BOX */
        #dialogue-box {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            height: 150px;
            background: #000;
            border: 4px solid white;
            padding: 20px;
            display: none; /* Hidden by default */
            box-sizing: border-box;
            font-size: 28px;
            line-height: 1.2;
        }

        .face-portrait {
            float: left;
            width: 100px;
            height: 100px;
            margin-right: 20px;
            border: 2px solid white;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 50px;
        }

        .next-arrow {
            position: absolute;
            bottom: 10px;
            right: 20px;
            animation: bounce 0.5s infinite alternate;
        }

        /* SCREENS */
        .screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: auto;
            transition: opacity 0.5s;
        }

        .hidden { opacity: 0; pointer-events: none; }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: 60px;
            color: var(--soul);
            margin: 0;
            text-shadow: 0 0 20px var(--soul);
        }

        button {
            background: transparent;
            color: white;
            font-family: 'VT323', monospace;
            font-size: 30px;
            border: 2px solid white;
            padding: 10px 40px;
            margin-top: 40px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        button:hover {
            background: white;
            color: black;
            transform: scale(1.1);
            box-shadow: 0 0 20px white;
        }

        .controls {
            margin-top: 30px;
            color: #888;
            text-align: center;
            font-size: 20px;
        }

        .key { color: var(--gold); border: 1px solid #555; padding: 2px 6px; border-radius: 4px; }

        /* CRT EFFECTS */
        .scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 50;
        }

        @keyframes bounce { from { transform: translateY(0); } to { transform: translateY(5px); } }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>

    <!-- UI -->
    <div id="ui-layer">
        <div class="hud-row">
            <div style="display:flex; align-items:center;">
                <span>DIVIJA</span>
                <span style="font-size:18px; color:#888; margin-left:10px;">LV 25</span>
                <div class="bar-container">
                    <div class="bar-fill" id="hp-fill"></div>
                </div>
                <span id="hp-text" style="margin-left:10px">20/20</span>
            </div>
            <div style="display:flex; align-items:center;">
                <span style="color:var(--soul)">TP</span>
                <div class="bar-container" style="width:100px; border-color:var(--soul)">
                    <div class="bar-fill" id="tp-fill"></div>
                </div>
                <span id="tp-text" style="margin-left:10px">0%</span>
            </div>
        </div>

        <div id="dialogue-box">
            <div class="face-portrait" id="face-icon">‚ô•</div>
            <div id="dialogue-text"></div>
            <div class="next-arrow">‚ñº</div>
        </div>
    </div>

    <!-- TITLE SCREEN -->
    <div id="title-screen" class="screen">
        <h1>THE CALCULUS<br>OF THE HEART</h1>
        <div style="color: #666; margin-top: 10px;">v.2.0.1 // STABLE BUILD</div>
        <div class="controls">
            <span class="key">ARROWS</span> Move &nbsp; 
            <span class="key">SHIFT</span> Focus &nbsp; 
            <span class="key">Z</span> Interact &nbsp; 
            <span class="key">X</span> Overload (Bomb)
        </div>
        <button id="btn-start">Initiate</button>
    </div>

    <!-- GAME OVER -->
    <div id="game-over" class="screen hidden">
        <h1 style="color: var(--heart)">HEART BROKEN</h1>
        <p style="font-size: 24px;">But you are too stubborn to quit.</p>
        <button id="btn-retry">Refuse to Die</button>
    </div>

    <!-- VICTORY -->
    <div id="victory-screen" class="screen hidden">
        <h1 style="color: var(--gold)">PROOF COMPLETE</h1>
        <div style="text-align: center; max-width: 600px; font-size: 24px; line-height: 1.5;">
            <p>From the undefined variables, we derived a constant.</p>
            <p>Happy Birthday, Divija.</p>
            <p style="margin-top: 30px; color: var(--soul); font-size: 32px;">
                I will always be DADDY üëë
            </p>
        </div>
        <button onclick="location.reload()">Re-Run Simulation</button>
    </div>
</div>

<script>
/**
 * ENGINE: HEART_CORE
 * A robust, canvas-based bullet hell engine with visual novel elements.
 */

const CONFIG = {
    w: 800,
    h: 600,
    fps: 60,
    colors: {
        bg: '#050505',
        arena: '#FFF',
        heart: '#ff4d4d',
        soul: '#00f3ff',
        bullet: '#FFF',
        warn: '#FF0000'
    }
};

// --- AUDIO SYNTHESIZER (No external files needed) ---
const Synth = {
    ctx: null,
    init() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    play(type) {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);

        if (type === 'blip') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(800, t);
            gain.gain.setValueAtTime(0.1, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
            osc.start(t);
            osc.stop(t + 0.05);
        } else if (type === 'hurt') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, t);
            osc.frequency.linearRampToValueAtTime(50, t + 0.3);
            gain.gain.setValueAtTime(0.2, t);
            gain.gain.linearRampToValueAtTime(0, t + 0.3);
            osc.start(t);
            osc.stop(t + 0.3);
        } else if (type === 'graze') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(2000, t);
            gain.gain.setValueAtTime(0.05, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
            osc.start(t);
            osc.stop(t + 0.1);
        } else if (type === 'bomb') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(100, t);
            osc.frequency.linearRampToValueAtTime(800, t + 1.0);
            gain.gain.setValueAtTime(0.2, t);
            gain.gain.linearRampToValueAtTime(0, t + 1.0);
            osc.start(t);
            osc.stop(t + 1.0);
        }
    }
};

// --- INPUT HANDLER ---
const Input = {
    keys: {},
    init() {
        window.addEventListener('keydown', e => {
            if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
            this.keys[e.key.toLowerCase()] = true;
            this.keys[e.code] = true;
        });
        window.addEventListener('keyup', e => {
            this.keys[e.key.toLowerCase()] = false;
            this.keys[e.code] = false;
        });
    },
    isDown(action) {
        if(action === 'up') return this.keys['arrowup'] || this.keys['w'];
        if(action === 'down') return this.keys['arrowdown'] || this.keys['s'];
        if(action === 'left') return this.keys['arrowleft'] || this.keys['a'];
        if(action === 'right') return this.keys['arrowright'] || this.keys['d'];
        if(action === 'focus') return this.keys['shift'] || this.keys['shiftleft'];
        if(action === 'fire') return this.keys['z'] || this.keys['enter'];
        if(action === 'bomb') return this.keys['x'];
        return false;
    }
};

// --- GAME ENTITIES ---
class Player {
    constructor() {
        this.x = CONFIG.w / 2;
        this.y = CONFIG.h / 2;
        this.r = 4; // Hitbox radius
        this.spriteR = 10; // Visual radius
        this.speed = 5;
        this.focusSpeed = 2.5;
        this.hp = 20;
        this.maxHp = 20;
        this.tp = 0; // Tension Points (0-100)
        this.invuln = 0;
    }

    update(arena) {
        const spd = Input.isDown('focus') ? this.focusSpeed : this.speed;
        
        if (Input.isDown('left')) this.x -= spd;
        if (Input.isDown('right')) this.x += spd;
        if (Input.isDown('up')) this.y -= spd;
        if (Input.isDown('down')) this.y += spd;

        // Clamp to Arena
        this.x = Math.max(arena.x + 8, Math.min(arena.x + arena.w - 8, this.x));
        this.y = Math.max(arena.y + 8, Math.min(arena.y + arena.h - 8, this.y));

        if (this.invuln > 0) this.invuln--;

        // Bomb Mechanic
        if (Input.isDown('bomb') && this.tp >= 100) {
            this.tp = 0;
            Game.bullets = []; // Clear screen
            Game.particles.push(new Effect(this.x, this.y, 'nova'));
            Synth.play('bomb');
            this.hp = Math.min(this.maxHp, this.hp + 2); // Small heal
            Game.shake = 20;
        }
    }

    draw(ctx) {
        if (this.invuln > 0 && Math.floor(Date.now()/50)%2) return;

        // Draw Heart
        ctx.fillStyle = CONFIG.colors.heart;
        ctx.beginPath();
        const topCurveHeight = this.spriteR * 0.3;
        ctx.moveTo(this.x, this.y + this.spriteR * 0.3);
        ctx.bezierCurveTo(this.x, this.y, this.x - this.spriteR, this.y, this.x - this.spriteR, this.y + topCurveHeight);
        ctx.bezierCurveTo(this.x - this.spriteR, this.y + (this.spriteR + topCurveHeight) / 2, 
                          this.x, this.y + (this.spriteR + topCurveHeight), 
                          this.x, this.y + this.spriteR * 1.5);
        ctx.bezierCurveTo(this.x, this.y + (this.spriteR + topCurveHeight), 
                          this.x + this.spriteR, this.y + (this.spriteR + topCurveHeight) / 2, 
                          this.x + this.spriteR, this.y + topCurveHeight);
        ctx.bezierCurveTo(this.x + this.spriteR, this.y, this.x, this.y, this.x, this.y + this.spriteR * 0.3);
        ctx.fill();

        // Draw Hitbox (Soul) when focused
        if (Input.isDown('focus')) {
            ctx.fillStyle = CONFIG.colors.soul;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
        }
    }
}

class Bullet {
    constructor(x, y, angle, speed, type) {
        this.x = x; this.y = y;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.type = type; // 0: pellet, 1: orb, 2: beam
        this.active = true;
        this.grazed = false;
        this.timer = 0;
    }

    update() {
        this.timer++;
        
        // Behaviors
        if (this.type === 'sine') {
            this.x += this.vx + Math.cos(this.timer * 0.1) * 2;
            this.y += this.vy;
        } else if (this.type === 'accel') {
            this.vx *= 1.02;
            this.vy *= 1.02;
            this.x += this.vx;
            this.y += this.vy;
        } else {
            this.x += this.vx;
            this.y += this.vy;
        }

        // Bounds check (wide bounds for reentry)
        if (this.x < -50 || this.x > CONFIG.w + 50 || this.y < -50 || this.y > CONFIG.h + 50) {
            this.active = false;
        }
    }

    draw(ctx) {
        ctx.fillStyle = CONFIG.colors.bullet;
        ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#888'; ctx.stroke();
    }
}

class Effect {
    constructor(x, y, type) {
        this.x = x; this.y = y;
        this.type = type;
        this.life = 30;
        this.maxLife = 30;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
    }
    draw(ctx) {
        const a = this.life / this.maxLife;
        ctx.globalAlpha = a;
        if (this.type === 'hit') ctx.fillStyle = CONFIG.colors.warn;
        else if (this.type === 'graze') ctx.fillStyle = CONFIG.colors.soul;
        else ctx.fillStyle = '#FFF';
        
        if (this.type === 'nova') {
            ctx.beginPath(); ctx.arc(this.x, this.y, (30-this.life)*10, 0, Math.PI*2); 
            ctx.strokeStyle = CONFIG.colors.soul; ctx.stroke();
        } else {
            ctx.fillRect(this.x, this.y, 4, 4);
        }
        ctx.globalAlpha = 1;
    }
}

// --- MAIN ENGINE ---
const Game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: null,
    
    // State
    state: 'MENU',
    player: null,
    bullets: [],
    particles: [],
    
    // Arena (The Box)
    arena: { x: 0, y: 0, w: 0, h: 0, targetW: 0, targetH: 0 },
    shake: 0,
    
    // Script
    scriptIndex: 0,
    scriptTimer: 0,
    textTimer: 0,
    fullText: "",
    currentText: "",
    isTextDone: false,
    
    // Patterns
    battleTimer: 0,
    patternType: '',

    init() {
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = CONFIG.w;
        this.canvas.height = CONFIG.h;
        Input.init();
        
        // Game Loop
        const loop = () => {
            this.update();
            this.draw();
            requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
    },

    start() {
        this.player = new Player();
        this.bullets = [];
        this.particles = [];
        this.scriptIndex = 0;
        
        // Initial Arena Size
        this.arena = { x: 300, y: 350, w: 200, h: 150, targetW: 200, targetH: 150 };
        
        this.state = 'SCRIPT';
        this.nextScript();
        
        document.getElementById('title-screen').classList.add('hidden');
        document.getElementById('game-over').classList.add('hidden');
        document.getElementById('ui-layer').style.opacity = 1;
    },

    // --- SCRIPT DATA (The Story) ---
    script: [
        { type: 'text', face: 'sys', text: "SYSTEM: Boot sequence initiated." },
        { type: 'text', face: 'sys', text: "SYSTEM: Subject 'Divija' detected." },
        { type: 'text', face: 'sys', text: "ANALYSIS: High levels of stubbornness and... brilliance." },
        { type: 'text', face: 'heart', text: "Who are you? Why is it so dark?" },
        { type: 'text', face: 'sys', text: "I am the Logic. You are the Heart. I am here to test your variables." },
        { type: 'text', face: 'sys', text: "Let's see how you handle a little CHAOS." },
        
        // BATTLE 1: RAIN
        { type: 'battle', pattern: 'rain', duration: 400 },
        
        { type: 'text', face: 'heart', text: "Is that all you got? I've handled worse Mondays." },
        { type: 'text', face: 'sys', text: "Arrogance. A common defense mechanism." },
        { type: 'text', face: 'sys', text: "You push people away. You build walls. Like this box." },
        { type: 'text', face: 'heart', text: "Walls keep me safe. Walls make sense." },
        { type: 'text', face: 'sys', text: "Walls also keep the light out. Try to calculate this trajectory." },

        // BATTLE 2: SINE WAVES
        { type: 'battle', pattern: 'sine', duration: 500 },

        { type: 'text', face: 'sys', text: "Impressive. You graze the danger, but you don't let it touch you." },
        { type: 'text', face: 'heart', text: "It's called efficiency." },
        { type: 'text', face: 'sys', text: "It's called fear. Fear of being known. Fear of being loved." },
        { type: 'text', face: 'sys', text: "Why do you hide your kindness behind a sharp tongue?" },
        { type: 'text', face: 'heart', text: "Because... if I'm soft, I break." },
        { type: 'text', face: 'sys', text: "Incorrect. The strongest materials are malleable." },
        { type: 'text', face: 'sys', text: "Prepare for the final proof." },

        // BATTLE 3: SPIRAL CHAOS
        { type: 'battle', pattern: 'spiral', duration: 600 },

        { type: 'text', face: 'heart', text: "I... I'm still standing." },
        { type: 'text', face: 'sys', text: "Q.E.D. The proof is complete." },
        { type: 'text', face: 'sys', text: "You are tough. But you are also loved." },
        { type: 'text', face: 'sys', text: "And I am not just the System." },
        { type: 'win' }
    ],

    nextScript() {
        if (this.scriptIndex >= this.script.length) return;
        
        const event = this.script[this.scriptIndex];
        this.scriptIndex++;

        if (event.type === 'text') {
            this.state = 'DIALOGUE';
            this.startDialogue(event.text, event.face);
            // Shrink arena for intimacy
            this.arena.targetW = CONFIG.w - 100;
            this.arena.targetH = 150;
        } else if (event.type === 'battle') {
            this.state = 'COMBAT';
            this.battleTimer = event.duration;
            this.patternType = event.pattern;
            document.getElementById('dialogue-box').style.display = 'none';
            // Expand arena for combat
            this.arena.targetW = 400;
            this.arena.targetH = 400;
        } else if (event.type === 'win') {
            document.getElementById('victory-screen').classList.remove('hidden');
            this.state = 'WIN';
        }
    },

    startDialogue(text, face) {
        const box = document.getElementById('dialogue-box');
        const faceIcon = document.getElementById('face-icon');
        box.style.display = 'block';
        
        faceIcon.innerText = face === 'heart' ? '‚ô•' : '‚ö°';
        faceIcon.style.color = face === 'heart' ? CONFIG.colors.heart : CONFIG.colors.soul;
        
        this.fullText = text;
        this.currentText = "";
        this.textTimer = 0;
        this.isTextDone = false;
    },

    update() {
        // Arena Interpolation (The Box Breathing)
        const lerp = (start, end, amt) => (1 - amt) * start + amt * end;
        this.arena.x = (CONFIG.w - this.arena.w) / 2;
        this.arena.y = (CONFIG.h - this.arena.h) / 2 + (this.state === 'DIALOGUE' ? 200 : 0);
        this.arena.w = lerp(this.arena.w, this.arena.targetW, 0.1);
        this.arena.h = lerp(this.arena.h, this.arena.targetH, 0.1);

        // Screen Shake
        if (this.shake > 0) {
            this.ctx.save();
            const dx = (Math.random() - 0.5) * this.shake;
            const dy = (Math.random() - 0.5) * this.shake;
            this.ctx.translate(dx, dy);
            this.shake *= 0.9;
        }

        if (this.state === 'COMBAT') {
            this.player.update(this.arena);
            this.updateBullets();
            this.handleSpawner();
            
            if (this.battleTimer <= 0 && this.bullets.length === 0) {
                this.nextScript();
            }
        } else if (this.state === 'DIALOGUE') {
            this.player.update(this.arena);
            // Typewriter effect
            if (!this.isTextDone) {
                this.textTimer++;
                if (this.textTimer % 2 === 0) {
                    this.currentText = this.fullText.substring(0, this.currentText.length + 1);
                    document.getElementById('dialogue-text').innerText = this.currentText;
                    Synth.play('blip');
                    if (this.currentText === this.fullText) this.isTextDone = true;
                }
            }
            
            if (Input.isDown('fire') && !this.keyLock) {
                if (this.isTextDone) {
                    this.keyLock = true;
                    this.nextScript();
                } else {
                    // Skip text
                    this.currentText = this.fullText;
                    this.isTextDone = true;
                    document.getElementById('dialogue-text').innerText = this.currentText;
                    this.keyLock = true;
                }
            }
            if (!Input.isDown('fire')) this.keyLock = false;
        }

        // Particles always update
        this.particles.forEach((p, i) => {
            p.update();
            if (p.life <= 0) this.particles.splice(i, 1);
        });
        
        // Update UI
        const hpPct = (this.player.hp / this.player.maxHp) * 100;
        document.getElementById('hp-fill').style.width = hpPct + '%';
        document.getElementById('hp-text').innerText = Math.floor(this.player.hp) + "/" + this.player.maxHp;
        
        document.getElementById('tp-fill').style.width = this.player.tp + '%';
        document.getElementById('tp-text').innerText = Math.floor(this.player.tp) + "%";
        
        if (this.shake > 0) this.ctx.restore();
    },

    handleSpawner() {
        this.battleTimer--;
        const t = this.battleTimer;
        
        // Prevent negative timer glitches
        if (t < 0) return;

        const center = { x: CONFIG.w/2, y: this.arena.y + this.arena.h/2 };

        if (this.patternType === 'rain') {
            if (t % 10 === 0) {
                const x = this.arena.x + Math.random() * this.arena.w;
                this.bullets.push(new Bullet(x, 0, Math.PI/2, 4, 'linear'));
            }
        } else if (this.patternType === 'sine') {
            if (t % 15 === 0) {
                this.bullets.push(new Bullet(center.x, 100, Math.PI/2, 3, 'sine'));
            }
            if (t % 60 === 0) {
                // Targeted shot
                const angle = Math.atan2(this.player.y - 100, this.player.x - center.x);
                this.bullets.push(new Bullet(center.x, 100, angle, 5, 'accel'));
            }
        } else if (this.patternType === 'spiral') {
            if (t % 4 === 0) {
                const angle = t * 0.1;
                this.bullets.push(new Bullet(center.x, 150, angle, 3, 'linear'));
                this.bullets.push(new Bullet(center.x, 150, angle + Math.PI, 3, 'linear'));
            }
        }
    },

    updateBullets() {
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            const b = this.bullets[i];
            b.update();
            
            if (!b.active) {
                this.bullets.splice(i, 1);
                continue;
            }

            const dx = b.x - this.player.x;
            const dy = b.y - this.player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            // Graze (Close call)
            if (dist < 30 && !b.grazed) {
                b.grazed = true;
                this.player.tp = Math.min(100, this.player.tp + 5);
                this.particles.push(new Effect(b.x, b.y, 'graze'));
                Synth.play('graze');
            }

            // Hit
            if (dist < this.player.r + 4) { // Hitbox radius + bullet radius
                if (this.player.invuln === 0) {
                    this.player.hp -= 4;
                    this.player.invuln = 60;
                    this.shake = 10;
                    this.particles.push(new Effect(this.player.x, this.player.y, 'hit'));
                    Synth.play('hurt');
                    b.active = false;
                    
                    if (this.player.hp <= 0) {
                        this.state = 'GAMEOVER';
                        document.getElementById('game-over').classList.remove('hidden');
                    }
                }
            }
        }
    },

    draw() {
        // Clear Background
        this.ctx.fillStyle = CONFIG.colors.bg;
        this.ctx.fillRect(0, 0, CONFIG.w, CONFIG.h);

        if (!this.player) return;

        // Draw Arena (The Box)
        this.ctx.strokeStyle = '#FFF';
        this.ctx.lineWidth = 4;
        this.ctx.strokeRect(this.arena.x, this.arena.y, this.arena.w, this.arena.h);

        // Draw Entities (clipped to box if needed, but we usually want bullets visible outside)
        this.ctx.save();
        this.ctx.beginPath();
        this.ctx.rect(this.arena.x, this.arena.y, this.arena.w, this.arena.h);
        this.ctx.clip(); // Clip Player to box

        // Grid Background inside box
        this.ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        this.ctx.lineWidth = 1;
        const offset = (Date.now() / 20) % 20;
        for(let i=0; i<CONFIG.w; i+=20) {
            this.ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, CONFIG.h); ctx.stroke();
            this.ctx.beginPath(); ctx.moveTo(0, i + offset); ctx.lineTo(CONFIG.w, i + offset); ctx.stroke();
        }

        this.player.draw(this.ctx);
        this.ctx.restore();

        // Draw Bullets (Above clip so they look threatening)
        this.bullets.forEach(b => b.draw(this.ctx));
        this.particles.forEach(p => p.draw(this.ctx));
        
        // Enemy "Eye" (The System)
        if (this.state === 'COMBAT') {
            const cx = CONFIG.w/2;
            const cy = this.arena.y - 40;
            this.ctx.fillStyle = '#000';
            this.ctx.strokeStyle = CONFIG.colors.soul;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath(); ctx.arc(cx, cy, 30, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            this.ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI*2); ctx.fillStyle=CONFIG.colors.soul; ctx.fill();
        }
    }
};

const ctx = document.getElementById('gameCanvas').getContext('2d');

// --- EVENT LISTENERS ---
document.getElementById('btn-start').addEventListener('click', () => {
    Synth.init(); // Initialize audio context on user gesture
    Game.init();
    Game.start();
});

document.getElementById('btn-retry').addEventListener('click', () => {
    Game.start();
});

</script>
</body>
</html>
