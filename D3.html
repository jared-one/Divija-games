<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Divija: Shattered Reflection (Enhanced Final)</title>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

    :root {
      --bg-dark: #0a0a12;
      --ui-white: #f0f0f0;
      --accent-red: #ff3366;
      --accent-gold: #ffd700;
      --soul-green: #00ffcc;
      --shadow-purple: #2d004d;
    }

    body {
      margin: 0;
      background-color: #000;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: 'VT323', monospace;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    /* Scanline Overlay */
    #crt-layer {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background:
        linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
      background-size: 100% 2px, 3px 100%;
      pointer-events: none;
      z-index: 999;
    }

    #game-stage {
      width: 800px;
      height: 600px;
      background: var(--bg-dark);
      border: 4px solid var(--ui-white);
      position: relative;
      box-shadow: 0 0 40px rgba(0, 255, 204, 0.1);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* --- VISUALS --- */
    #bg-canvas {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      z-index: 0; opacity: 0.6;
    }

    #actors-layer {
      position: absolute; top: 10%; width: 100%; height: 40%;
      z-index: 10;
      display: flex; justify-content: space-between; padding: 0 100px; box-sizing: border-box;
      align-items: flex-end;
    }

    .actor { width: 180px; height: 220px; transition: filter 0.5s, opacity 0.5s; }

    /* --- UI & HUD --- */
    #ui-layer {
      position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
      width: 740px; height: 220px; z-index: 20;
      display: none;
    }

    #dialogue-box {
      width: 100%; height: 100%;
      border: 4px solid var(--ui-white);
      background: #000;
      padding: 20px; box-sizing: border-box;
      font-size: 28px; color: white;
      position: relative;
    }

    .stats-bar {
      position: absolute; top: 20px; left: 20px;
      color: white; font-size: 24px; z-index: 30;
      text-shadow: 2px 2px black;
    }

    #hp-container {
      display: inline-block; width: 150px; height: 20px;
      background: #333; margin-left: 10px; vertical-align: middle;
      border: 2px solid white;
    }
    #hp-fill {
      width: 100%; height: 100%; background: var(--accent-gold);
      transition: width 0.2s cubic-bezier(0.4, 0.0, 0.2, 1);
    }
    #hp-text { margin-left: 10px; }

    #enemy-hp-container {
      position: absolute; top: 20px; right: 20px;
      width: 300px; height: 10px; background: #333;
      border: 2px solid #555; z-index: 30;
      display: none;
    }
    #enemy-hp-fill { width: 100%; height: 100%; background: var(--ui-white); transition: width 0.5s; }

    /* Small sound toggle (keeps your UI style) */
    #sound-toggle {
      position: absolute;
      top: 42px;
      right: 20px;
      z-index: 40;
      border: 2px solid var(--ui-white);
      color: var(--ui-white);
      font-size: 18px;
      padding: 4px 10px;
      background: rgba(0,0,0,0.5);
      cursor: pointer;
      display: none; /* show after start */
    }
    #sound-toggle.off {
      border-color: #666;
      color: #888;
    }

    /* --- MENUS --- */
    .choice-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 15px;
      margin-top: 20px; width: 80%;
    }
    .action-btn {
      border: 2px solid var(--accent-red);
      color: var(--accent-red);
      padding: 10px 20px;
      text-transform: uppercase;
      font-size: 24px;
      cursor: pointer;
      text-align: left;
      transition: all 0.1s;
    }
    .action-btn:hover, .action-btn.active {
      background: var(--accent-red); color: black;
      box-shadow: 0 0 15px var(--accent-red);
    }

    /* --- MINIGAME --- */
    #bullet-box {
      position: absolute;
      top: 50%; left: 50%; transform: translate(-50%, -60%);
      width: 250px; height: 250px;
      border: 4px solid white;
      background: black;
      z-index: 50; display: none;
    }

    /* --- MOBILE CONTROLS --- */
    #mobile-controls {
      position: absolute; bottom: 20px; right: 20px;
      z-index: 900; display: none;
      width: 150px; height: 150px;
    }
    .dpad-row { display: flex; justify-content: center; width: 100%; }
    .dpad-btn {
      width: 45px; height: 45px;
      background: rgba(255,255,255,0.2);
      border: 2px solid rgba(255,255,255,0.5);
      color: white; font-size: 20px;
      margin: 2px;
      display: flex; justify-content: center; align-items: center;
      border-radius: 8px;
      touch-action: manipulation;
    }
    .dpad-btn:active { background: rgba(255,255,255,0.6); }

    /* --- ANIMATIONS --- */
    .shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
    @keyframes shake {
      10%, 90% { transform: translate3d(-4px, 0, 0); }
      20%, 80% { transform: translate3d(6px, 0, 0); }
      30%, 50%, 70% { transform: translate3d(-8px, 0, 0); }
      40%, 60% { transform: translate3d(8px, 0, 0); }
    }

    .divija-float { animation: float 4s ease-in-out infinite; }
    .echo-glitch { animation: glitch 0.18s infinite; opacity: 0.92; filter: drop-shadow(0 0 10px rgba(255, 51, 102, 0.35)); }
    .echo-calm { animation: float 3.5s ease-in-out infinite; opacity: 0.85; filter: drop-shadow(0 0 10px rgba(240, 240, 240, 0.15)); }

    @keyframes float { 0%,100%{transform:translateY(0);} 50%{transform:translateY(-10px);} }
    @keyframes glitch {
      0% { transform: translate(0,0); }
      20% { transform: translate(-2px, 2px); }
      40% { transform: translate(-2px, -2px); }
      60% { transform: translate(2px, 2px); }
      80% { transform: translate(2px, -2px); }
      100% { transform: translate(0,0); }
    }

    /* --- START SCREEN --- */
    #start-overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: #000; z-index: 100;
      display: flex; flex-direction: column;
      justify-content: center; align-items: center;
      text-align: center;
    }
    h1 { font-size: 60px; color: var(--ui-white); margin: 0; text-shadow: 4px 4px var(--accent-red); }
    .blink { animation: blink 1s infinite; }
    @keyframes blink { 50% { opacity: 0; } }
  </style>
</head>

<body>
  <div id="crt-layer"></div>

  <div id="game-stage">
    <canvas id="bg-canvas" width="800" height="600"></canvas>

    <!-- BGM (Vercel root path) -->
    <audio id="bgm" src="/fallen-down.mp3" preload="auto" loop playsinline></audio>

    <!-- HUD -->
    <div class="stats-bar">
      DIVIJA <span style="color:var(--accent-red)">LV 1</span>
      <div id="hp-container"><div id="hp-fill"></div></div>
      <span id="hp-text">20/20</span>
    </div>

    <div id="enemy-hp-container"><div id="enemy-hp-fill"></div></div>
    <div id="sound-toggle">SOUND: ON</div>

    <!-- SVGs (improved but same vibe) -->
    <svg width="0" height="0">
      <defs>
        <linearGradient id="skinGrad" x1="0" y1="0" x2="0" y2="1">
          <stop offset="0" stop-color="#e6c3a2"/>
          <stop offset="1" stop-color="#caa07f"/>
        </linearGradient>

        <linearGradient id="hoodGrad" x1="0" y1="0" x2="1" y2="1">
          <stop offset="0" stop-color="#0f0f10"/>
          <stop offset="1" stop-color="#242428"/>
        </linearGradient>

        <linearGradient id="shirtGrad" x1="0" y1="0" x2="0" y2="1">
          <stop offset="0" stop-color="#4558ff"/>
          <stop offset="1" stop-color="#2c38a8"/>
        </linearGradient>

        <filter id="softGlow" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur stdDeviation="2.2" result="blur"/>
          <feMerge>
            <feMergeNode in="blur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>

        <!-- DIVIJA -->
        <g id="svg-divija">
          <ellipse cx="100" cy="240" rx="62" ry="10" fill="rgba(0,0,0,0.55)"/>

          <!-- scarf / ribbon -->
          <path d="M55,120 C85,105 115,105 145,120"
                stroke="#ff3366" stroke-width="14" stroke-linecap="round" opacity="0.95">
            <animate attributeName="d"
              values="M55,120 C85,105 115,105 145,120;
                      M55,120 C85,112 115,98 145,120;
                      M55,120 C85,105 115,105 145,120"
              dur="2.6s" repeatCount="indefinite"/>
          </path>

          <!-- body -->
          <rect x="66" y="120" width="68" height="98" rx="12" fill="url(#shirtGrad)" />
          <rect x="70" y="125" width="60" height="90" rx="10" fill="rgba(0,0,0,0.10)"/>

          <!-- arms -->
          <path d="M68,140 Q40,160 50,192"
                stroke="url(#skinGrad)" stroke-width="12" stroke-linecap="round" fill="none"/>
          <path d="M132,140 Q160,160 150,192"
                stroke="url(#skinGrad)" stroke-width="12" stroke-linecap="round" fill="none"/>

          <!-- head -->
          <circle cx="100" cy="78" r="36" fill="url(#skinGrad)"/>
          <!-- hair/hood -->
          <path d="M56,60 Q100,12 144,60 L144,106 Q100,86 56,106 Z" fill="url(#hoodGrad)"/>
          <path d="M62,64 Q100,24 138,64" stroke="rgba(255,51,102,0.75)" stroke-width="5" fill="none"/>

          <!-- eyes -->
          <ellipse id="eyeL" cx="88" cy="80" rx="3.2" ry="5.2" fill="#1b1b1b">
            <animate attributeName="ry" values="5.2;5.2;0.4;5.2" dur="4.8s" repeatCount="indefinite"/>
          </ellipse>
          <ellipse id="eyeR" cx="112" cy="80" rx="3.2" ry="5.2" fill="#1b1b1b">
            <animate attributeName="ry" values="5.2;5.2;0.4;5.2" dur="4.8s" repeatCount="indefinite"/>
          </ellipse>

          <!-- small mouth -->
          <path d="M96,94 Q100,97 104,94" stroke="#3a2a2a" stroke-width="2.5" fill="none" stroke-linecap="round"/>

          <!-- tiny heart charm -->
          <path d="M100,150
                   C96,143 86,145 90,155
                   C92,160 100,165 100,165
                   C100,165 108,160 110,155
                   C114,145 104,143 100,150 Z"
                fill="rgba(255,215,0,0.85)" filter="url(#softGlow)"/>
        </g>

        <!-- ECHO -->
        <g id="svg-echo">
          <!-- shards -->
          <g opacity="0.95" filter="url(#softGlow)">
            <polygon points="100,42 148,160 52,160" fill="#101014" stroke="#f0f0f0" stroke-width="2">
              <animate attributeName="points"
                values="100,42 148,160 52,160;
                        100,32 158,150 42,150;
                        100,42 148,160 52,160"
                dur="0.18s" repeatCount="indefinite"/>
            </polygon>

            <polygon points="35,110 58,128 30,150" fill="#0b0b0f" stroke="rgba(240,240,240,0.7)" stroke-width="1"/>
            <polygon points="165,90 150,120 178,132" fill="#0b0b0f" stroke="rgba(240,240,240,0.7)" stroke-width="1"/>
            <polygon points="78,170 100,190 62,210" fill="#0b0b0f" stroke="rgba(240,240,240,0.7)" stroke-width="1"/>
            <polygon points="122,170 138,210 100,192" fill="#0b0b0f" stroke="rgba(240,240,240,0.7)" stroke-width="1"/>
          </g>

          <!-- eye -->
          <circle cx="100" cy="112" r="13" fill="rgba(255,0,0,0.78)">
            <animate attributeName="r" values="13;12;14;13" dur="1.4s" repeatCount="indefinite"/>
          </circle>
          <circle cx="100" cy="112" r="4" fill="#140000"/>

          <!-- glitch rectangles -->
          <rect x="40" y="78" width="12" height="10" fill="#fff" opacity="0.35">
            <animate attributeName="x" values="40;44;38;40" dur="0.24s" repeatCount="indefinite"/>
          </rect>
          <rect x="150" y="58" width="10" height="9" fill="#fff" opacity="0.35">
            <animate attributeName="y" values="58;66;54;58" dur="0.21s" repeatCount="indefinite"/>
          </rect>
        </g>
      </defs>
    </svg>

    <div id="actors-layer">
      <svg class="actor divija-float" viewBox="0 0 200 250"><use href="#svg-divija"/></svg>
      <svg class="actor" id="echo-sprite" viewBox="0 0 200 250" style="opacity:0"><use href="#svg-echo"/></svg>
    </div>

    <!-- UI Box -->
    <div id="ui-layer">
      <div id="dialogue-box">
        <div id="writer-text">* The reflection is silent.</div>

        <div id="main-menu" class="choice-grid" style="display:none;">
          <div class="action-btn active" data-idx="0">FIGHT</div>
          <div class="action-btn" data-idx="1">ACT</div>
          <div class="action-btn" data-idx="2">ITEM</div>
          <div class="action-btn" data-idx="3">MERCY</div>
        </div>

        <div id="act-menu" class="choice-grid" style="display:none;">
          <div class="action-btn active" data-idx="0">CHECK</div>
          <div class="action-btn" data-idx="1">LISTEN</div>
          <div class="action-btn" data-idx="2">REASSURE</div>
          <div class="action-btn" data-idx="3">BACK</div>
        </div>

        <div class="tap-hint" style="font-size:18px; color:#888; position:absolute; bottom:10px; right:10px;">
          [ENTER] or [TAP]
        </div>
      </div>
    </div>

    <canvas id="bullet-box" width="250" height="250"></canvas>

    <!-- Mobile D-PAD -->
    <div id="mobile-controls">
      <div class="dpad-row"><div class="dpad-btn" id="m-up">▲</div></div>
      <div class="dpad-row">
        <div class="dpad-btn" id="m-left">◀</div>
        <div class="dpad-btn" style="opacity:0"></div>
        <div class="dpad-btn" id="m-right">▶</div>
      </div>
      <div class="dpad-row"><div class="dpad-btn" id="m-down">▼</div></div>
    </div>

    <!-- Start Screen -->
    <div id="start-overlay">
      <h1>DIVIJA</h1>
      <h2 style="color:#666">SHATTERED REFLECTION</h2>
      <br />
      <p class="blink">[ PRESS ENTER OR TAP ]</p>
      <p style="font-size:14px; color:#444">Recommended: Sound ON</p>
    </div>
  </div>

  <script>
    /*
      Enhanced version:
      - Better audio mixing + BGM fade
      - Fair hit handling (invulnerability)
      - Richer narrative with phase transitions
      - Improved menu navigation (2x2 grid)
      - Bullet patterns scale with "pressure" (violence makes it harder)
    */

    // ------------------ AUDIO ------------------
    const AudioSys = {
      ctx: null,
      master: null,
      sfxGain: null,
      muted: false,

      init() {
        if (!this.ctx) {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          this.master = this.ctx.createGain();
          this.sfxGain = this.ctx.createGain();

          this.master.gain.value = 0.9;
          this.sfxGain.gain.value = 0.9;

          this.sfxGain.connect(this.master);
          this.master.connect(this.ctx.destination);
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
      },

      setMuted(m) {
        this.muted = !!m;
        if (this.master) this.master.gain.value = this.muted ? 0 : 0.9;
        BGM.setMuted(this.muted);
      },

      playTone(freq, type='sine', dur=0.08, vol=0.08) {
        if (this.muted) return;
        if (!this.ctx) return;

        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.type = type;
        osc.frequency.setValueAtTime(freq, t);

        gain.gain.setValueAtTime(Math.max(0.0001, vol), t);
        gain.gain.exponentialRampToValueAtTime(0.0001, t + dur);

        osc.connect(gain);
        gain.connect(this.sfxGain);

        osc.start(t);
        osc.stop(t + dur);
      },

      playNoise(dur=0.10, vol=0.10, hpFreq=900) {
        if (this.muted) return;
        if (!this.ctx) return;

        const sr = this.ctx.sampleRate;
        const len = Math.floor(sr * dur);
        const buf = this.ctx.createBuffer(1, len, sr);
        const data = buf.getChannelData(0);
        for (let i = 0; i < len; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / len);

        const src = this.ctx.createBufferSource();
        src.buffer = buf;

        const filter = this.ctx.createBiquadFilter();
        filter.type = "highpass";
        filter.frequency.value = hpFreq;

        const gain = this.ctx.createGain();
        gain.gain.value = vol;

        src.connect(filter);
        filter.connect(gain);
        gain.connect(this.sfxGain);

        src.start();
        src.stop(this.ctx.currentTime + dur);
      },

      playSFX(type) {
        this.init();
        if (this.muted) return;

        switch (type) {
          case 'select':
            this.playTone(440, 'square', 0.06, 0.07);
            break;
          case 'confirm':
            this.playTone(660, 'square', 0.07, 0.08);
            this.playTone(990, 'triangle', 0.05, 0.04);
            break;
          case 'start':
            this.playTone(330, 'triangle', 0.08, 0.08);
            this.playTone(660, 'triangle', 0.12, 0.07);
            break;
          case 'text':
            this.playTone(210, 'square', 0.04, 0.025);
            break;
          case 'glitch':
            this.playNoise(0.09, 0.10, 1100);
            this.playTone(120, 'sawtooth', 0.10, 0.05);
            break;
          case 'hit':
            this.playNoise(0.10, 0.14, 800);
            this.playTone(150, 'sawtooth', 0.12, 0.10);
            this.playTone(100, 'sawtooth', 0.12, 0.08);
            break;
          case 'heal':
            this.playTone(440, 'sine', 0.16, 0.07);
            setTimeout(() => this.playTone(660, 'sine', 0.28, 0.07), 90);
            break;
          case 'menuOpen':
            this.playTone(523.25, 'triangle', 0.08, 0.06);
            break;
          case 'menuClose':
            this.playTone(392.00, 'triangle', 0.08, 0.06);
            break;
          case 'dodgeStart':
            this.playNoise(0.09, 0.08, 1200);
            break;
          case 'dodgeEnd':
            this.playTone(440, 'triangle', 0.07, 0.05);
            break;
          case 'win':
            this.playTone(523.25, 'triangle', 0.10, 0.08);
            setTimeout(() => this.playTone(659.25, 'triangle', 0.12, 0.08), 90);
            setTimeout(() => this.playTone(783.99, 'triangle', 0.14, 0.08), 190);
            break;
          case 'lose':
            this.playTone(220, 'sawtooth', 0.18, 0.10);
            setTimeout(() => this.playTone(164.81, 'sawtooth', 0.22, 0.10), 140);
            break;
        }
      }
    };

    const BGM = {
      el: null,
      started: false,
      muted: false,
      targetVol: 0.38,
      fadeMs: 900,

      init() {
        this.el = document.getElementById('bgm');
      },

      setMuted(m) {
        this.muted = !!m;
        if (!this.el) return;
        this.el.muted = this.muted;
        if (this.muted) this.el.volume = 0;
      },

      async start() {
        if (!this.el || this.started) return;
        this.started = true;

        try {
          this.el.currentTime = 0;
          this.el.volume = 0;
          this.el.muted = this.muted;

          await this.el.play();

          const steps = 22;
          const stepTime = this.fadeMs / steps;
          let i = 0;
          const timer = setInterval(() => {
            i++;
            if (this.muted) this.el.volume = 0;
            else this.el.volume = Math.min(this.targetVol, (this.targetVol * i) / steps);
            if (i >= steps) clearInterval(timer);
          }, stepTime);
        } catch (e) {
          // Autoplay blocked. We'll try again on next user gesture.
          this.started = false;
        }
      },

      fadeOut(ms=700) {
        if (!this.el) return;
        const startVol = this.el.volume;
        const steps = 18;
        const stepTime = ms / steps;
        let i = 0;
        const timer = setInterval(() => {
          i++;
          const v = Math.max(0, startVol * (1 - i / steps));
          this.el.volume = v;
          if (i >= steps) {
            clearInterval(timer);
            this.el.pause();
          }
        }, stepTime);
      }
    };

    document.addEventListener('visibilitychange', () => {
      if (!BGM.el) return;
      if (document.hidden) BGM.el.pause();
      else if (BGM.started && !BGM.muted) BGM.el.play().catch(()=>{});
    });

    // ------------------ GAME STATE ------------------
    const Game = {
      state: 'start', // start, dialogue, menu, act_menu, dodge, gameover
      hp: 20,
      maxHp: 20,

      enemyHp: 100,
      enemyMax: 100,

      actLevel: 0,     // empathy progress
      pressure: 0,     // increases with violence, lowers with empathy. affects patterns.
      phase: 1,        // 1..3
      flags: {
        phase2Shown: false,
        phase3Shown: false,
        endingShown: false
      },

      items: {
        breath: 2
      },

      textSpeed: 30,
      loopId: null,
      invulnUntil: 0,
    };

    // ------------------ DOM ------------------
    const UI = {
      overlay: document.getElementById('start-overlay'),
      writer: document.getElementById('writer-text'),
      mainMenu: document.getElementById('main-menu'),
      actMenu: document.getElementById('act-menu'),
      hpFill: document.getElementById('hp-fill'),
      hpText: document.getElementById('hp-text'),
      enemyBar: document.getElementById('enemy-hp-container'),
      enemyFill: document.getElementById('enemy-hp-fill'),
      echo: document.getElementById('echo-sprite'),
      bulletCanvas: document.getElementById('bullet-box'),
      dialogueBox: document.getElementById('ui-layer'),
      mobileControls: document.getElementById('mobile-controls'),
      soundToggle: document.getElementById('sound-toggle'),
      stage: document.getElementById('game-stage'),
    };

    // ------------------ INPUT ------------------
    const Keys = {
      w:false,a:false,s:false,d:false,
      ArrowUp:false,ArrowDown:false,ArrowLeft:false,ArrowRight:false
    };

    function setKey(k, v) {
      if (Keys.hasOwnProperty(k)) Keys[k] = v;
      const lower = (typeof k === 'string') ? k.toLowerCase() : k;
      if (Keys.hasOwnProperty(lower)) Keys[lower] = v;
    }

    window.addEventListener('keydown', (e) => {
      setKey(e.key, true);

      if (e.key === 'Enter' || e.key === ' ') handleConfirm();
      if (Game.state === 'menu' || Game.state === 'act_menu') handleMenuNav(e.key);
    });

    window.addEventListener('keyup', (e) => setKey(e.key, false));

    // Mobile D-Pad Events
    ['up','down','left','right'].forEach(dir => {
      const btn = document.getElementById(`m-${dir}`);
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        Keys[`Arrow${dir.charAt(0).toUpperCase()+dir.slice(1)}`] = true;
      }, {passive:false});
      btn.addEventListener('touchend', (e) => {
        e.preventDefault();
        Keys[`Arrow${dir.charAt(0).toUpperCase()+dir.slice(1)}`] = false;
      }, {passive:false});
    });

    UI.soundToggle.addEventListener('click', (e) => {
      e.stopPropagation();
      AudioSys.init();
      AudioSys.setMuted(!AudioSys.muted);
      UI.soundToggle.classList.toggle('off', AudioSys.muted);
      UI.soundToggle.textContent = AudioSys.muted ? 'SOUND: OFF' : 'SOUND: ON';
      AudioSys.playSFX('select');
    });

    document.body.addEventListener('click', (e) => {
      // menu clicks
      if (e.target.classList.contains('action-btn')) {
        const idx = parseInt(e.target.dataset.idx, 10);
        if (Game.state === 'menu') {
          selectMenuOption(idx);
          executeAction();
        } else if (Game.state === 'act_menu') {
          selectMenuOption(idx);
          executeAct();
        }
        return;
      }

      // tap to advance (but not during dodge)
      if (Game.state !== 'menu' && Game.state !== 'act_menu' && Game.state !== 'dodge') {
        handleConfirm();
      }
    });

    // ------------------ MENU NAV (2x2) ------------------
    let menuIdx = 0;

    function handleMenuNav(key) {
      // 2x2 grid: idx 0 1 / 2 3
      let r = Math.floor(menuIdx / 2);
      let c = menuIdx % 2;

      const k = key.toLowerCase();
      const left  = (key === 'ArrowLeft' || k === 'a');
      const right = (key === 'ArrowRight' || k === 'd');
      const up    = (key === 'ArrowUp' || k === 'w');
      const down  = (key === 'ArrowDown' || k === 's');

      if (left) c = (c + 1) % 2;        // flip col
      if (right) c = (c + 1) % 2;       // flip col (same effect; feels snappy)
      if (up) r = (r + 1) % 2;          // flip row
      if (down) r = (r + 1) % 2;        // flip row

      const newIdx = r * 2 + c;
      if (newIdx !== menuIdx) {
        menuIdx = newIdx;
        selectMenuOption(menuIdx);
        AudioSys.playSFX('select');
      }
    }

    function selectMenuOption(idx) {
      menuIdx = idx;
      const parent = (Game.state === 'menu') ? UI.mainMenu : UI.actMenu;
      Array.from(parent.children).forEach((btn, i) => {
        if (i === idx) btn.classList.add('active');
        else btn.classList.remove('active');
      });
    }

    // ------------------ TYPING ------------------
    const Typing = {
      queueData: [],
      callback: null,
      isBusy: false,
      interval: null,
      currentLine: "",
      charIndex: 0,

      queue(lines, onComplete) {
        this.queueData = lines;
        this.callback = onComplete || null;
        Game.state = 'dialogue';
        this.isBusy = false;
        this.next();
      },

      next() {
        if (this.isBusy) return;

        if (this.queueData.length === 0) {
          if (this.callback) this.callback();
          return;
        }

        const item = this.queueData.shift();

        if (typeof item === 'function') {
          item();
          this.next();
          return;
        }

        this.isBusy = true;
        this.currentLine = item;
        this.charIndex = 0;
        UI.writer.innerHTML = "";
        clearInterval(this.interval);

        this.interval = setInterval(() => {
          UI.writer.innerHTML += this.currentLine.charAt(this.charIndex);
          if (this.currentLine.charAt(this.charIndex) !== ' ') AudioSys.playSFX('text');
          this.charIndex++;

          if (this.charIndex >= this.currentLine.length) {
            this.finish(true);
          }
        }, Game.textSpeed);
      },

      finish(completedNaturally=false) {
        clearInterval(this.interval);
        if (!completedNaturally) UI.writer.innerHTML = this.currentLine;
        this.isBusy = false;
      }
    };

    // ------------------ CORE FLOW ------------------
    function handleConfirm() {
      AudioSys.init();
      BGM.start();

      if (Game.state === 'start') {
        UI.overlay.style.display = 'none';
        UI.dialogueBox.style.display = 'block';
        UI.soundToggle.style.display = 'block';
        AudioSys.playSFX('start');
        startStory();
        return;
      }

      if (Game.state === 'dialogue') {
        if (Typing.isBusy) Typing.finish(false);
        else Typing.next();
        return;
      }

      if (Game.state === 'menu') executeAction();
      if (Game.state === 'act_menu') executeAct();
    }

    function updateHUD() {
      const pct = Math.max(0, (Game.hp / Game.maxHp) * 100);
      UI.hpFill.style.width = pct + '%';
      UI.hpText.textContent = Math.max(0, Game.hp) + "/" + Game.maxHp;

      const ePct = Math.max(0, (Game.enemyHp / Game.enemyMax) * 100);
      UI.enemyFill.style.width = ePct + '%';
    }

    function showMenu(customText) {
      Game.state = 'menu';
      UI.actMenu.style.display = 'none';
      UI.mainMenu.style.display = 'grid';
      UI.writer.innerHTML = customText || "* The Echo awaits your answer.";
      menuIdx = 0;
      selectMenuOption(0);
      AudioSys.playSFX('menuOpen');
    }

    function showActMenu() {
      Game.state = 'act_menu';
      UI.mainMenu.style.display = 'none';
      UI.actMenu.style.display = 'grid';

      // dynamic label to add emotional progression without changing layout
      UI.actMenu.children[1].textContent = (Game.actLevel >= 2) ? "REMEMBER" : "LISTEN";

      UI.writer.innerHTML = "* What will you do?";
      menuIdx = 0;
      selectMenuOption(0);
      AudioSys.playSFX('menuOpen');
    }

    // ------------------ STORY ------------------
    function startStory() {
      Game.hp = Game.maxHp;
      Game.enemyHp = Game.enemyMax;
      Game.actLevel = 0;
      Game.pressure = 0;
      Game.phase = 1;
      Game.flags.phase2Shown = false;
      Game.flags.phase3Shown = false;
      Game.flags.endingShown = false;
      Game.items.breath = 2;
      updateHUD();

      Typing.queue([
        "* The mirror is cold to the touch.",
        "* Your fingertips leave fog on the glass.",
        "* For a moment... the fog looks like handwriting.",
        "* It spells your name.",
        () => {
          UI.enemyBar.style.display = 'block';
        },
        "* The reflection lags behind you by half a heartbeat.",
        "* And then it smiles when you do not.",
        () => {
          UI.echo.style.opacity = 1;
          UI.echo.classList.add('echo-glitch');
          AudioSys.playSFX('glitch');
        },
        "ECHO: \"Do you know what they see when they look at you?\"",
        "ECHO: \"Not talent.\"",
        "ECHO: \"Not certainty.\"",
        "ECHO: \"Only mistakes... wearing your face.\"",
        "* Your Soul trembles.",
        startTutorial
      ]);
    }

    function startTutorial() {
      Typing.queue([
        "* TUTORIAL: Your Soul (Green) is fragile.",
        "* Move with Arrow Keys or WASD.",
        "* Avoid the white fragments.",
        "* If you get hit, you’ll blink briefly (invulnerable for a moment).",
      ], () => startDodge('tutorial'));
    }

    function maybePhaseTransitions(onDone) {
      // Called after a dodge ends, before returning to menu, to add emotional beats.
      if (!Game.flags.phase2Shown && Game.enemyHp <= 60) {
        Game.flags.phase2Shown = true;
        Game.phase = 2;
        Typing.queue([
          "* The Echo’s edges stop screaming.",
          "* The cracks in it become... lines.",
          "* Like something that was repaired, not ruined.",
          "ECHO: \"I learned to talk like this.\"",
          "ECHO: \"So you would listen.\"",
          "* The mirror feels less like an enemy...",
          "* and more like a confession."
        ], onDone);
        return;
      }

      if (!Game.flags.phase3Shown && Game.enemyHp <= 25) {
        Game.flags.phase3Shown = true;
        Game.phase = 3;
        Typing.queue([
          "* The Echo’s red eye flickers.",
          "* Behind the glare... there is fear.",
          "ECHO: \"If you stop hating yourself...\"",
          "ECHO: \"what happens to me?\"",
          "* You realize something painful:",
          "* it was never trying to destroy you.",
          "* it was trying to keep you small enough to be safe."
        ], onDone);
        return;
      }

      onDone();
    }

    // ------------------ ACTIONS ------------------
    function executeAction() {
      UI.mainMenu.style.display = 'none';
      AudioSys.playSFX('confirm');

      const actions = ['fight', 'act', 'item', 'mercy'];
      const choice = actions[menuIdx];

      if (choice === 'fight') {
        // Violence reduces enemy HP a bit but increases pressure => harder dodges, more damage vibe
        Game.enemyHp = Math.max(0, Game.enemyHp - 10);
        Game.pressure = Math.min(10, Game.pressure + 2);
        updateHUD();

        Typing.queue([
          "* You strike the glass.",
          "* It cracks.",
          "* The sound is exactly like your worst memory.",
          "ECHO: \"See? That’s all you know.\"",
          "* The Echo grows sharper."
        ], () => startDodge('hard'));
      }

      if (choice === 'act') {
        showActMenu();
      }

      if (choice === 'item') {
        if (Game.items.breath <= 0) {
          Typing.queue(["* (You have nothing left to use.)"], () => showMenu());
          return;
        }

        if (Game.hp >= Game.maxHp) {
          Typing.queue(["* Your HP is maxed out."], () => showMenu());
          return;
        }

        Game.items.breath--;
        Game.hp = Math.min(Game.maxHp, Game.hp + 9);
        Game.pressure = Math.max(0, Game.pressure - 1);
        updateHUD();
        AudioSys.playSFX('heal');

        Typing.queue([
          "* You take a deep breath.",
          "* Your shoulders drop by one impossible inch.",
          `* (Breaths left: ${Game.items.breath})`,
          "* HP recovered."
        ], () => startDodge('easy'));
      }

      if (choice === 'mercy') {
        // Mercy is about enough empathy progress and low pressure
        const canSpare = (Game.actLevel >= 4) || (Game.enemyHp <= 0);
        if (canSpare) {
          winGame();
        } else {
          Typing.queue([
            "* The Echo refuses to listen yet.",
            "* It’s still speaking in borrowed cruelty.",
            "* You need to REASSURE it more."
          ], () => startDodge('medium'));
        }
      }
    }

    function executeAct() {
      UI.actMenu.style.display = 'none';
      AudioSys.playSFX('confirm');

      const acts = ['check', 'listenOrRemember', 'reassure', 'back'];
      const choice = acts[menuIdx];

      if (choice === 'back') {
        showMenu();
        return;
      }

      if (choice === 'check') {
        Typing.queue([
          "* ECHO - ATK 5 DEF 0",
          "* It is a manifestation of imposter syndrome.",
          "* It feeds on uncertainty...",
          "* ...and calls it honesty."
        ], () => showMenu("* The Echo awaits your answer."));
        return; // does not end turn
      }

      if (choice === 'listenOrRemember') {
        // As actLevel grows, "LISTEN" becomes "REMEMBER"
        if (Game.actLevel >= 2) {
          Game.actLevel++;
          Game.enemyHp = Math.max(0, Game.enemyHp - 18);
          Game.pressure = Math.max(0, Game.pressure - 2);
          updateHUD();

          Typing.queue([
            "* You remember a time you tried anyway.",
            "* Not perfectly.",
            "* Just honestly.",
            "ECHO: \"That doesn't count...\"",
            "* You whisper: \"It does.\"",
            "* The mirror warms."
          ], () => startDodge('easy'));
        } else {
          Game.actLevel++;
          Game.enemyHp = Math.max(0, Game.enemyHp - 12);
          Game.pressure = Math.max(0, Game.pressure - 1);
          updateHUD();

          Typing.queue([
            "* You listen to the voices without obeying them.",
            "ECHO: \"Everyone is better than you.\"",
            "* You say: \"Maybe.\"",
            "* You add: \"But I’m still allowed to be here.\""
          ], () => startDodge('medium'));
        }
        return;
      }

      if (choice === 'reassure') {
        Game.actLevel++;
        Game.enemyHp = Math.max(0, Game.enemyHp - 28);
        Game.pressure = Math.max(0, Game.pressure - 2);
        updateHUD();

        const linesByProgress = [
          "* You say: \"I know you're scared.\"",
          "* You say: \"We’re learning.\"",
          "* You say: \"It’s okay to make mistakes.\"",
          "* You say: \"You tried to protect me.\"",
          "* You say: \"But we don’t need pain as proof anymore.\""
        ];

        const text = linesByProgress[Math.min(Game.actLevel - 1, linesByProgress.length - 1)];

        Typing.queue([
          text,
          "ECHO: \"...\"",
          "* The Echo’s shaking slows.",
        ], () => startDodge('easy'));
        return;
      }
    }

    // ------------------ BULLET HELL ------------------
    function startDodge(difficulty) {
      Game.state = 'dodge';
      UI.writer.innerHTML = "";
      UI.bulletCanvas.style.display = 'block';
      UI.mainMenu.style.display = 'none';
      UI.actMenu.style.display = 'none';

      AudioSys.playSFX('dodgeStart');

      if (window.innerWidth < 800) UI.mobileControls.style.display = 'block';

      const ctx = UI.bulletCanvas.getContext('2d');
      const W = 250, H = 250;

      let soul = { x: 125, y: 125 };
      let bullets = [];
      let frame = 0;

      // Duration scales a bit with phase/difficulty (emotional tension)
      const baseFrames = (difficulty === 'tutorial') ? 280 : (difficulty === 'easy' ? 340 : (difficulty === 'medium' ? 400 : 440));
      const maxFrames = Math.floor(baseFrames + Game.pressure * 6);

      function spawnBullet() {
        // pressure increases spawn rate slightly
        const p = Game.pressure;

        if (difficulty === 'tutorial') {
          if (frame % 22 === 0) bullets.push({x: Math.random()*W, y: -10, vx: 0, vy: 2.1, r: 4, type:'white'});
          return;
        }

        if (difficulty === 'easy') {
          if (frame % Math.max(12, 16 - Math.floor(p/2)) === 0) {
            bullets.push({x: Math.random()*W, y: -10, vx: 0, vy: 2.9 + p*0.05, r: 4, type:'white'});
          }
          // gentle side drift
          if (Game.phase >= 2 && frame % 60 === 0) {
            bullets.push({x: -10, y: 20 + Math.random()*210, vx: 2.1, vy: 0, r: 4, type:'white'});
          }
          return;
        }

        if (difficulty === 'medium') {
          // spiral-ish
          if (frame % Math.max(9, 12 - Math.floor(p/2)) === 0) {
            const a = frame * 0.12;
            bullets.push({x: 125, y: -10, vx: Math.sin(a) * (2.2 + p*0.1), vy: 3.0 + p*0.06, r: 4, type:'white'});
          }
          // aimed shots (phase 2+)
          if (Game.phase >= 2 && frame % 70 === 0) {
            const dx = soul.x - 125;
            const dy = soul.y - 0;
            const mag = Math.max(1, Math.hypot(dx, dy));
            const sp = 3.0 + p*0.08;
            bullets.push({x: 125, y: -10, vx: (dx/mag)*sp, vy: (dy/mag)*sp, r: 4, type:'white'});
          }
          return;
        }

        // HARD
        // crossfire + sweep
        if (frame % Math.max(7, 10 - Math.floor(p/2)) === 0) {
          const a = frame * 0.14;
          bullets.push({x: 125, y: -10, vx: Math.sin(a) * (3.0 + p*0.12), vy: 3.2 + p*0.06, r: 4, type:'white'});
        }
        if (frame % 45 === 0) {
          bullets.push({x: 0, y: Math.random()*220+15, vx: 3.2 + p*0.08, vy: 0, r: 4, type:'white'});
          bullets.push({x: W, y: Math.random()*220+15, vx: -(3.2 + p*0.08), vy: 0, r: 4, type:'white'});
        }

        // phase 3: "mirror shard" bouncers (scarier but fair)
        if (Game.phase >= 3 && frame % 80 === 0) {
          const vx = (Math.random() < 0.5 ? -1 : 1) * (2.4 + p*0.05);
          const vy = 2.6 + p*0.05;
          bullets.push({x: 20 + Math.random()*210, y: 10, vx, vy, r: 5, type:'shard', bounces: 2});
        }
      }

      function loop(ts) {
        if (Game.state !== 'dodge') return;

        // background trails
        ctx.fillStyle = 'rgba(0,0,0,0.35)';
        ctx.fillRect(0,0,W,H);

        // move soul
        const spd = 4;
        if ((Keys.w || Keys.ArrowUp) && soul.y > 8) soul.y -= spd;
        if ((Keys.s || Keys.ArrowDown) && soul.y < H-8) soul.y += spd;
        if ((Keys.a || Keys.ArrowLeft) && soul.x > 8) soul.x -= spd;
        if ((Keys.d || Keys.ArrowRight) && soul.x < W-8) soul.x += spd;

        // draw soul (blink during invuln)
        const now = performance.now();
        const inv = now < Game.invulnUntil;
        if (!inv || Math.floor(now/80) % 2 === 0) {
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--soul-green').trim();
          ctx.beginPath(); ctx.arc(soul.x, soul.y, 6, 0, Math.PI*2); ctx.fill();
        }

        // spawn bullets
        spawnBullet();

        // update/draw bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
          const b = bullets[i];

          b.x += b.vx;
          b.y += b.vy;

          // shard bounce behavior
          if (b.type === 'shard') {
            // bounce off walls a limited number of times
            if ((b.x < 6 && b.vx < 0) || (b.x > W-6 && b.vx > 0)) {
              if (b.bounces > 0) {
                b.vx *= -1;
                b.bounces--;
              }
            }
          }

          // draw
          if (b.type === 'shard') {
            ctx.fillStyle = 'rgba(240,240,240,0.95)';
            ctx.beginPath();
            ctx.moveTo(b.x, b.y - b.r);
            ctx.lineTo(b.x + b.r, b.y + b.r);
            ctx.lineTo(b.x - b.r, b.y + b.r);
            ctx.closePath();
            ctx.fill();
          } else {
            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
          }

          // collision
          const dx = soul.x - b.x;
          const dy = soul.y - b.y;
          const rr = (b.r + 6);
          if (dx*dx + dy*dy < rr*rr) {
            // remove bullet on hit
            bullets.splice(i, 1);
            takeDamage();
            continue;
          }

          // cleanup
          if (b.y > H+20 || b.x < -30 || b.x > W+30) {
            bullets.splice(i, 1);
          }
        }

        // border
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 4;
        ctx.strokeRect(0,0,W,H);

        frame++;
        if (frame < maxFrames && Game.hp > 0) {
          Game.loopId = requestAnimationFrame(loop);
        } else {
          endDodge();
        }
      }

      if (Game.loopId) cancelAnimationFrame(Game.loopId);
      Game.loopId = requestAnimationFrame(loop);
    }

    function takeDamage() {
      const now = performance.now();
      if (now < Game.invulnUntil) return; // invuln frames (fairness)

      AudioSys.playSFX('hit');
      Game.hp -= 2;
      updateHUD();

      Game.invulnUntil = now + 650;

      // screen shake
      UI.stage.classList.remove('shake');
      void UI.stage.offsetWidth;
      UI.stage.classList.add('shake');

      if (Game.hp <= 0) {
        cancelAnimationFrame(Game.loopId);
        Game.state = 'gameover';
        UI.bulletCanvas.style.display = 'none';
        UI.mobileControls.style.display = 'none';
        BGM.fadeOut(700);
        AudioSys.playSFX('lose');

        Typing.queue([
          "* Your resolve shattered...",
          "* But something inside you still whispers:",
          "* \"Try again.\""
        ], () => location.reload());
      }
    }

    function endDodge() {
      cancelAnimationFrame(Game.loopId);
      UI.bulletCanvas.style.display = 'none';
      UI.mobileControls.style.display = 'none';
      AudioSys.playSFX('dodgeEnd');

      if (Game.state === 'gameover') return;

      // Echo visuals calm as progress increases
      if (Game.enemyHp <= 60) {
        UI.echo.classList.remove('echo-glitch');
        UI.echo.classList.add('echo-calm');
      }

      maybePhaseTransitions(() => showMenu());
    }

    function winGame() {
      Game.state = 'gameover';
      UI.mainMenu.style.display = 'none';
      UI.actMenu.style.display = 'none';

      UI.echo.style.opacity = 0.55;
      UI.echo.classList.remove('echo-glitch');
      UI.echo.classList.add('echo-calm');

      AudioSys.playSFX('win');
      BGM.fadeOut(1200);

      Typing.queue([
        "* The Echo stops fighting.",
        "ECHO: \"I thought if I hurt you first...\"",
        "ECHO: \"...it would hurt less when the world did.\"",
        "* You place your palm on the glass.",
        "* The mirror does not feel cold anymore.",
        "* It feels like a hand held from the other side.",
        "ECHO: \"Can I stay?\"",
        "* You answer without hesitation:",
        "* \"Yes. But we learn a kinder language.\"",
        "* The Echo steps forward.",
        "* The reflection aligns with you.",
        "* The cracks remain... but they look like light.",
        "YOU WON.",
        "* (Refresh to play again.)"
      ]);
    }

    // ------------------ BG PARTICLES ------------------
    (function bgAnim() {
      const cvs = document.getElementById('bg-canvas');
      const ctx = cvs.getContext('2d');

      const parts = Array.from({length: 46}, () => ({
        x: Math.random()*800,
        y: Math.random()*600,
        s: Math.random()*14 + 6,
        v: Math.random()*0.55 + 0.12,
        a: Math.random()*0.08 + 0.06
      }));

      function anim() {
        ctx.clearRect(0,0,800,600);
        parts.forEach(p => {
          p.y -= p.v;
          if (p.y < -30) { p.y = 630; p.x = Math.random()*800; }

          ctx.fillStyle = `rgba(255,255,255,${p.a})`;
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(p.x + p.s, p.y + p.s/2);
          ctx.lineTo(p.x + p.s/2, p.y + p.s);
          ctx.closePath();
          ctx.fill();
        });
        requestAnimationFrame(anim);
      }
      anim();
    })();

    // ------------------ INIT ------------------
    BGM.init();
    updateHUD();
  </script>
</body>
</html>
