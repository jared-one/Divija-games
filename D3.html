<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BLASTER | NULL VOID</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=JetBrains+Mono:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --void: #050505;
            --void-light: #0a0a0a;
            --math-cyan: #00F3FF;
            --warn-red: #FF2A6D;
            --divine-gold: #FFD700;
            --purple-glow: #9D00FF;
            --glitch-green: #00FF9D;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            background: var(--void);
            color: var(--math-cyan);
            font-family: 'JetBrains Mono', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 1000px;
            aspect-ratio: 16/9;
            background: var(--void-light);
            border: 2px solid var(--math-cyan);
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.15);
            overflow: hidden;
        }

        canvas { display: block; width: 100%; height: 100%; }

        #ui-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 25px;
            z-index: 10;
        }

        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }

        .score-block { text-align: left; }
        .level-display { color: var(--warn-red); font-size: 10px; letter-spacing: 0.2em; margin-bottom: 5px; }
        .score-value { font-size: 28px; font-weight: 700; color: var(--divine-gold); text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }

        .entropy-section { text-align: right; }
        .entropy-bar {
            width: 200px; height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--math-cyan);
            margin-bottom: 5px;
        }
        .entropy-fill {
            height: 100%;
            background: var(--math-cyan);
            box-shadow: 0 0 10px var(--math-cyan);
            transition: width 0.1s linear;
        }
        .entropy-fill.crit { background: var(--warn-red); box-shadow: 0 0 15px var(--warn-red); }

        /* SCREENS */
        #start-screen, #game-over-screen, #win-screen, #level-screen {
            position: absolute; inset: 0;
            background: rgba(5, 5, 5, 0.95);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 100;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        #level-screen { background: rgba(5,5,5,0.8); pointer-events: none; display: none; }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: clamp(3rem, 8vw, 6rem);
            color: var(--math-cyan);
            text-shadow: 4px 4px 0px var(--purple-glow);
            margin-bottom: 1rem;
            letter-spacing: 0.1em;
            text-align: center;
        }

        p { color: #aaa; margin-bottom: 2rem; text-align: center; line-height: 1.6; max-width: 600px; padding: 0 20px; }
        
        button {
            background: transparent;
            color: var(--math-cyan);
            border: 2px solid var(--math-cyan);
            padding: 15px 40px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            letter-spacing: 0.2em;
            transition: 0.3s;
            text-transform: uppercase;
        }

        button:hover { background: var(--math-cyan); color: var(--void); box-shadow: 0 0 30px var(--math-cyan); }

        .punchline { font-size: 1.5rem; color: var(--warn-red); margin-top: 1rem; font-weight: bold; text-shadow: 0 0 10px var(--warn-red); }

        /* Touch Controls */
        #touch-controls {
            display: none; position: absolute; bottom: 20px; left: 50%;
            transform: translateX(-50%); pointer-events: auto;
        }
        .d-pad {
            display: grid; grid-template-columns: repeat(3, 60px); grid-template-rows: repeat(2, 60px); gap: 8px;
        }
        .d-btn {
            border: 1px solid var(--math-cyan); color: var(--math-cyan);
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; border-radius: 8px; background: rgba(0, 243, 255, 0.05);
        }
        .d-btn:active { background: var(--math-cyan); color: black; }
        .up { grid-column: 2; grid-row: 1; }
        .left { grid-column: 1; grid-row: 2; }
        .down { grid-column: 2; grid-row: 2; }
        .right { grid-column: 3; grid-row: 2; }

        @media (max-width: 768px) {
            #game-container { aspect-ratio: 3/4; height: 100vh; max-width: 100%; border: none; }
            #touch-controls { display: block; }
            h1 { font-size: 3rem; }
        }

        .vol-btn {
            position: absolute; top: 20px; right: 20px;
            border: 1px solid var(--math-cyan); color: var(--math-cyan);
            padding: 5px 10px; font-size: 10px; cursor: pointer; z-index: 200;
            background: rgba(0,0,0,0.5); pointer-events: auto;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <button id="mute-btn" class="vol-btn">AUDIO: OFF</button>

        <div id="ui-overlay">
            <div class="hud-top">
                <div class="score-block">
                    <div class="level-display">DIMENSION <span id="level-val">1</span></div>
                    <div class="score-value"><span id="score">0</span> / <span id="max-score">7</span></div>
                </div>
                <div class="entropy-section">
                    <div class="entropy-bar"><div class="entropy-fill" id="entropy-fill"></div></div>
                    <div style="font-size: 10px; letter-spacing: 0.1em;">SYSTEM STABILITY</div>
                </div>
            </div>

            <div id="touch-controls">
                <div class="d-pad">
                    <div class="d-btn up" data-key="ArrowUp">▲</div>
                    <div class="d-btn left" data-key="ArrowLeft">◀</div>
                    <div class="d-btn down" data-key="ArrowDown">▼</div>
                    <div class="d-btn right" data-key="ArrowRight">▶</div>
                </div>
            </div>
        </div>

        <div id="start-screen">
            <h1>BLASTER</h1>
            <p>The Void is unstable.<br>Collect the Divine Constants to restore order.<br>Avoid the corruption. Survive 3 Dimensions.</p>
            <button id="start-btn">INITIALIZE SYSTEM</button>
            <p style="font-size: 10px; margin-top: 20px; opacity: 0.6">HEADPHONES RECOMMENDED</p>
        </div>

        <div id="level-screen">
            <h1 style="font-size: 4rem" id="level-title">DIMENSION 2</h1>
            <p style="color: var(--divine-gold)">THREAT LEVEL INCREASING</p>
        </div>

        <div id="game-over-screen" style="display: none;">
            <h1 style="color: var(--warn-red)">FAILURE</h1>
            <p>Entropy has consumed the equation.</p>
            <button id="retry-btn">REBOOT</button>
        </div>

        <div id="win-screen" style="display: none;">
            <h1 style="color: var(--divine-gold)">HARMONIZED</h1>
            <p>All Dimensions Stabilized.</p>
            <p class="punchline">I will always be DADDY</p>
            <button id="play-again-btn">NEW CYCLE</button>
        </div>
    </div>

    <script>
        /**
         * BLASTER: NULL VOID EDITION
         * Procedural Audio & Functional Physics Engine
         */

        // --- MATH & UTILS ---
        const R = (min, max) => Math.random() * (max - min) + min;
        const RI = (min, max) => Math.floor(R(min, max + 1));
        const LERP = (a, b, t) => a + (b - a) * t;
        const DIST = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
        const CLAMP = (v, min, max) => Math.min(Math.max(v, min), max);

        // --- AUDIO ENGINE (Procedural) ---
        const Audio = (() => {
            let ctx = null;
            let masterGain = null;
            let isMuted = true;
            let isPlaying = false;
            let nextNoteTime = 0;
            let noteIndex = 0;
            
            // Musical Constants
            const TEMPO = 110;
            const LOOKAHEAD = 25.0;
            const SCHEDULE_AHEAD = 0.1;
            const SCALE = [146.83, 174.61, 220.00, 261.63, 130.81]; // D minor pentatonic-ish bass

            const init = () => {
                if (ctx) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                ctx = new AudioContext();
                masterGain = ctx.createGain();
                masterGain.gain.value = 0.4;
                masterGain.connect(ctx.destination);
            };

            const toggle = () => {
                if (!ctx) init();
                if (ctx.state === 'suspended') ctx.resume();
                isMuted = !isMuted;
                if (!isMuted) {
                    masterGain.gain.setTargetAtTime(0.4, ctx.currentTime, 0.1);
                    isPlaying = true;
                    scheduler();
                } else {
                    masterGain.gain.setTargetAtTime(0, ctx.currentTime, 0.1);
                    isPlaying = false;
                }
                return !isMuted;
            };

            // Synthesizers
            const playBass = (time, freq) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                const filter = ctx.createBiquadFilter();

                osc.type = 'sawtooth';
                osc.frequency.value = freq / 2; // Sub bass

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, time);
                filter.frequency.exponentialRampToValueAtTime(800, time + 0.1);
                filter.frequency.exponentialRampToValueAtTime(200, time + 0.4);

                gain.gain.setValueAtTime(0.4, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);

                osc.start(time);
                osc.stop(time + 0.5);
            };

            const playArp = (time, freq) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                osc.type = 'square';
                osc.frequency.value = freq * 2;
                
                gain.gain.setValueAtTime(0.05, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);

                osc.connect(gain);
                gain.connect(masterGain);
                
                osc.start(time);
                osc.stop(time + 0.15);
            };

            // Sequencer
            const scheduler = () => {
                if (!isPlaying || isMuted) return;
                while (nextNoteTime < ctx.currentTime + SCHEDULE_AHEAD) {
                    const beat = noteIndex % 8;
                    // Bass on 0 and 4
                    if (beat === 0 || beat === 4) {
                        playBass(nextNoteTime, SCALE[Math.floor(noteIndex/16) % SCALE.length]);
                    }
                    // Arp every beat, changing notes
                    if (noteIndex % 2 === 0) {
                        playArp(nextNoteTime, SCALE[(noteIndex % 4)]);
                    }
                    
                    const secondsPerBeat = 60.0 / TEMPO;
                    nextNoteTime += 0.25 * secondsPerBeat; // 16th notes
                    noteIndex++;
                }
                setTimeout(scheduler, LOOKAHEAD);
            };

            // SFX
            const sfx = {
                collect: () => {
                    if (isMuted) return;
                    const t = ctx.currentTime;
                    const osc = ctx.createOscillator();
                    const g = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(880, t);
                    osc.frequency.exponentialRampToValueAtTime(1760, t + 0.1);
                    g.gain.setValueAtTime(0.3, t);
                    g.gain.linearRampToValueAtTime(0, t + 0.2);
                    osc.connect(g); g.connect(masterGain);
                    osc.start(t); osc.stop(t + 0.2);
                },
                hit: () => {
                    if (isMuted) return;
                    const t = ctx.currentTime;
                    const osc = ctx.createOscillator();
                    const g = ctx.createGain();
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(100, t);
                    osc.frequency.linearRampToValueAtTime(20, t + 0.3);
                    g.gain.setValueAtTime(0.5, t);
                    g.gain.linearRampToValueAtTime(0, t + 0.3);
                    osc.connect(g); g.connect(masterGain);
                    osc.start(t); osc.stop(t + 0.3);
                },
                win: () => {
                    if (isMuted) return;
                    const t = ctx.currentTime;
                    [0, 0.2, 0.4].forEach((d, i) => {
                        const osc = ctx.createOscillator();
                        const g = ctx.createGain();
                        osc.frequency.value = 440 + (i * 110);
                        g.gain.setValueAtTime(0.3, t+d);
                        g.gain.linearRampToValueAtTime(0, t+d+1);
                        osc.connect(g); g.connect(masterGain);
                        osc.start(t+d); osc.stop(t+d+1);
                    });
                }
            };

            return { toggle, sfx, getContext: () => ctx };
        })();

        // --- GAME CONSTANTS ---
        const CONFIG = {
            player: { size: 16, color: '#00F3FF', speed: 0.8, drag: 0.92 },
            levels: [
                { count: 3, speed: 2, entropyRate: 0.0003, text: "DIMENSION I: AWAKENING" },
                { count: 5, speed: 3, entropyRate: 0.0005, text: "DIMENSION II: CHAOS" },
                { count: 7, speed: 4.5, entropyRate: 0.0008, text: "DIMENSION III: VOID" }
            ],
            colors: {
                trail: ['rgba(0, 243, 255, 0.5)', 'rgba(157, 0, 255, 0.5)', 'rgba(255, 215, 0, 0.5)']
            }
        };

        // --- GAME STATE ---
        let state = {
            screen: 'start', // start, playing, levelup, gameover, win
            level: 0,
            score: 0,
            entropy: 1.0,
            w: 0, h: 0,
            shake: 0,
            beatPulse: 0
        };

        let player = { x: 0, y: 0, vx: 0, vy: 0, trail: [], iframes: 0 };
        let entities = [];
        let particles = [];
        let keys = {};

        // --- SETUP ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        const resize = () => {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            state.w = canvas.width;
            state.h = canvas.height;
        };
        window.onresize = resize;
        resize();

        // --- INPUT ---
        window.onkeydown = e => keys[e.key] = true;
        window.onkeyup = e => keys[e.key] = false;
        
        document.querySelectorAll('.d-btn').forEach(btn => {
            const k = btn.dataset.key;
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[k] = true; });
            btn.addEventListener('touchend', (e) => { e.preventDefault(); keys[k] = false; });
            btn.addEventListener('mousedown', () => keys[k] = true);
            btn.addEventListener('mouseup', () => keys[k] = false);
        });

        document.getElementById('mute-btn').onclick = (e) => {
            const active = Audio.toggle();
            e.target.innerText = active ? "AUDIO: ON" : "AUDIO: OFF";
            e.target.style.borderColor = active ? "var(--math-cyan)" : "#555";
        };

        // --- ENTITIES ---
        const spawnPlayer = () => {
            player = { 
                x: state.w/2, y: state.h/2, 
                vx: 0, vy: 0, 
                trail: [], iframes: 0 
            };
        };

        const createParticle = (x, y, color, speed) => ({
            x, y, 
            vx: R(-speed, speed), vy: R(-speed, speed),
            life: 1.0, decay: R(0.02, 0.05),
            color
        });

        const spawnLevel = (lvlIdx) => {
            const cfg = CONFIG.levels[lvlIdx];
            entities = [];
            
            // Spawn Collectibles
            for(let i=0; i<7; i++) {
                entities.push({
                    type: 'orb',
                    x: R(50, state.w-50), y: R(50, state.h-50),
                    val: ['∞', '∑', 'Ω', '∫', '∆', 'π', 'Ψ'][i],
                    t: R(0, 100)
                });
            }

            // Spawn Enemies
            for(let i=0; i<cfg.count; i++) {
                let ex, ey;
                if(R(0,1)>0.5) { ex = R(0, state.w); ey = -20; }
                else { ex = -20; ey = R(0, state.h); }
                
                // Mix enemy types based on level
                let eType = 0; // Chaser
                if (lvlIdx > 0 && i % 3 === 0) eType = 1; // Dasher
                if (lvlIdx > 1 && i % 4 === 0) eType = 2; // Wanderer

                entities.push({
                    type: 'enemy', eType,
                    x: ex, y: ey,
                    vx: 0, vy: 0,
                    speed: cfg.speed * (eType === 1 ? 1.5 : 1),
                    timer: 0
                });
            }
        };

        // --- PHYSICS & LOGIC ---
        const updatePhysics = () => {
            // Player Movement
            const acc = 0.5;
            if (keys['ArrowUp'] || keys['w']) player.vy -= acc;
            if (keys['ArrowDown'] || keys['s']) player.vy += acc;
            if (keys['ArrowLeft'] || keys['a']) player.vx -= acc;
            if (keys['ArrowRight'] || keys['d']) player.vx += acc;

            player.vx *= CONFIG.player.drag;
            player.vy *= CONFIG.player.drag;
            player.x += player.vx;
            player.y += player.vy;

            // Boundaries
            if(player.x < 0) { player.x = 0; player.vx *= -0.5; }
            if(player.x > state.w) { player.x = state.w; player.vx *= -0.5; }
            if(player.y < 0) { player.y = 0; player.vy *= -0.5; }
            if(player.y > state.h) { player.y = state.h; player.vy *= -0.5; }

            // Trail
            if(Math.hypot(player.vx, player.vy) > 1) {
                player.trail.push({x: player.x, y: player.y, l: 1});
            }
            player.trail.forEach(t => t.l -= 0.05);
            player.trail = player.trail.filter(t => t.l > 0);

            if(player.iframes > 0) player.iframes--;

            // Entities
            const lvlCfg = CONFIG.levels[state.level];
            
            entities.forEach(e => {
                if(e.type === 'orb') {
                    e.t += 0.05;
                    e.y += Math.sin(e.t) * 0.2;
                    
                    if(DIST(player, e) < 30) {
                        e.dead = true;
                        state.score++;
                        state.entropy = Math.min(1, state.entropy + 0.2);
                        Audio.sfx.collect();
                        // Particles
                        for(let i=0; i<10; i++) particles.push(createParticle(e.x, e.y, CONFIG.colors.trail[state.level], 5));
                    }
                } 
                else if(e.type === 'enemy') {
                    const dx = player.x - e.x;
                    const dy = player.y - e.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const nx = dx/dist;
                    const ny = dy/dist;

                    if (e.eType === 0) { // Standard Chaser
                        e.vx += nx * 0.2;
                        e.vy += ny * 0.2;
                    } 
                    else if (e.eType === 1) { // Dasher
                        e.timer++;
                        if (e.timer < 60) {
                            // Aim
                            e.vx *= 0.9; e.vy *= 0.9;
                        } else if (e.timer === 60) {
                            // Dash
                            e.vx = nx * e.speed * 8;
                            e.vy = ny * e.speed * 8;
                        } else if (e.timer > 80) {
                            e.timer = 0;
                        }
                    }
                    else if (e.eType === 2) { // Drifter
                        e.vx += R(-0.5, 0.5);
                        e.vy += R(-0.5, 0.5);
                        e.vx += nx * 0.05;
                        e.vy += ny * 0.05;
                    }

                    // Cap speed (except dashers mid-dash)
                    const v = Math.hypot(e.vx, e.vy);
                    if(e.eType !== 1 || e.timer < 60) {
                        if(v > e.speed) { e.vx = (e.vx/v)*e.speed; e.vy = (e.vy/v)*e.speed; }
                    }

                    e.x += e.vx; e.y += e.vy;

                    // Wrap
                    if(e.x < -20) e.x = state.w + 20;
                    if(e.x > state.w + 20) e.x = -20;
                    if(e.y < -20) e.y = state.h + 20;
                    if(e.y > state.h + 20) e.y = -20;

                    // Collision
                    if(player.iframes <= 0 && DIST(player, e) < 20) {
                        state.shake = 20;
                        player.iframes = 60;
                        state.entropy -= 0.3;
                        Audio.sfx.hit();
                        for(let i=0; i<15; i++) particles.push(createParticle(player.x, player.y, '#FF2A6D', 8));
                    }
                }
            });

            entities = entities.filter(e => !e.dead);
            particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= p.decay; });
            particles = particles.filter(p => p.life > 0);

            // Entropy
            state.entropy -= lvlCfg.entropyRate;
            if(player.iframes > 0) state.entropy -= 0.001; // Leak on hit
            
            // UI Update
            document.getElementById('score').innerText = state.score;
            document.getElementById('max-score').innerText = (state.level + 1) * 7;
            const bar = document.getElementById('entropy-fill');
            bar.style.width = (state.entropy * 100) + '%';
            if(state.entropy < 0.25) bar.classList.add('crit'); else bar.classList.remove('crit');

            // Win/Loss
            if(state.entropy <= 0) gameOver();
            if(state.score >= (state.level + 1) * 7) levelUp();
        };

        const levelUp = () => {
            if(state.level >= 2) {
                gameWin();
                return;
            }
            
            state.level++;
            state.screen = 'levelup';
            
            const scr = document.getElementById('level-screen');
            document.getElementById('level-title').innerText = CONFIG.levels[state.level].text;
            scr.style.display = 'flex';
            
            Audio.sfx.win();

            setTimeout(() => {
                scr.style.display = 'none';
                state.screen = 'playing';
                state.entropy = 1.0;
                spawnLevel(state.level);
                document.getElementById('level-val').innerText = state.level + 1;
            }, 2500);
        };

        const gameWin = () => {
            state.screen = 'win';
            document.getElementById('win-screen').style.display = 'flex';
            Audio.sfx.win();
        };

        const gameOver = () => {
            state.screen = 'gameover';
            document.getElementById('game-over-screen').style.display = 'flex';
        };

        // --- RENDER ---
        const draw = () => {
            // Screen Shake & Glitch
            let ox = 0, oy = 0;
            if(state.shake > 0) {
                ox = R(-state.shake, state.shake);
                oy = R(-state.shake, state.shake);
                state.shake *= 0.9;
                if(state.shake < 0.5) state.shake = 0;
            }

            // Background Fade
            ctx.fillStyle = `rgba(5, 5, 5, 0.4)`; // Trails effect
            ctx.fillRect(0, 0, state.w, state.h);

            ctx.save();
            ctx.translate(ox, oy);

            // Grid Pulse (Audio reactive)
            if(Audio.getContext() && !Audio.isMuted) {
                // Fake reactivity based on time since we generate audio
                const t = Date.now() / 1000;
                if(Math.floor(t * 2) % 2 === 0) state.beatPulse = 1; 
            }
            state.beatPulse *= 0.95;
            
            ctx.strokeStyle = 'rgba(0, 243, 255, 0.05)';
            ctx.lineWidth = 1 + state.beatPulse;
            ctx.beginPath();
            const grid = 50;
            for(let x=0; x<state.w; x+=grid) { ctx.moveTo(x,0); ctx.lineTo(x,state.h); }
            for(let y=0; y<state.h; y+=grid) { ctx.moveTo(0,y); ctx.lineTo(state.w,y); }
            ctx.stroke();

            // Particles
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.fillRect(p.x, p.y, 4, 4);
            });
            ctx.globalAlpha = 1;

            // Player Trail
            ctx.fillStyle = CONFIG.colors.trail[state.level];
            player.trail.forEach(t => {
                ctx.globalAlpha = t.l * 0.4;
                ctx.fillRect(t.x - 6, t.y - 6, 12, 12);
            });
            ctx.globalAlpha = 1;

            // Player
            if(player.iframes % 4 < 2) {
                ctx.shadowBlur = 20;
                ctx.shadowColor = CONFIG.player.color;
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(player.x, player.y, 8, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            // Entities
            entities.forEach(e => {
                if(e.type === 'orb') {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#FFD700';
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, 12 + Math.sin(e.t)*2, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.fillStyle = '#FFD700';
                    ctx.font = '14px JetBrains Mono';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(e.val, e.x, e.y);
                } else if (e.type === 'enemy') {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#FF2A6D';
                    ctx.fillStyle = '#FF2A6D';
                    
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    // Rotate based on type
                    if(e.eType === 0) ctx.rotate(Date.now()/200);
                    if(e.eType === 1) ctx.rotate(Math.atan2(e.vy, e.vx));
                    
                    const s = 14;
                    if(e.eType === 1) { // Triangle for dasher
                        ctx.beginPath();
                        ctx.moveTo(s, 0); ctx.lineTo(-s, s/2); ctx.lineTo(-s, -s/2);
                        ctx.fill();
                    } else { // Square/Diamond
                        ctx.fillRect(-s/2, -s/2, s, s);
                    }
                    ctx.restore();
                }
            });

            // RGB Shift Post-Process (Simulated)
            if(state.shake > 2) {
                const shift = state.shake;
                ctx.globalCompositeOperation = 'screen';
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.fillRect(0, R(0, state.h), state.w, 2);
                ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
                ctx.fillRect(0, R(0, state.h), state.w, 2);
                ctx.globalCompositeOperation = 'source-over';
            }

            ctx.restore();
        };

        // --- LOOP ---
        const loop = () => {
            if(state.screen === 'playing' || state.screen === 'levelup') {
                updatePhysics();
                draw();
            }
            requestAnimationFrame(loop);
        };

        // --- EVENTS ---
        document.getElementById('start-btn').onclick = () => {
            document.getElementById('start-screen').style.display = 'none';
            Audio.toggle(); // Start audio context on user gesture
            resetGame();
        };

        document.getElementById('retry-btn').onclick = () => {
            document.getElementById('game-over-screen').style.display = 'none';
            resetGame();
        };

        document.getElementById('play-again-btn').onclick = () => {
            document.getElementById('win-screen').style.display = 'none';
            resetGame();
        };

        const resetGame = () => {
            state.score = 0;
            state.level = 0;
            state.entropy = 1.0;
            state.screen = 'playing';
            spawnPlayer();
            spawnLevel(0);
            document.getElementById('level-val').innerText = "1";
        };

        // Start Loop
        requestAnimationFrame(loop);

    </script>
</body>
</html>
